<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Engine</name>
    </assembly>
    <members>
        <member name="T:Engine.Utility.FloatFn">
            <summary>
            A function which is closed over floats
            (they don't necessarily make guarantees about accuracy)
            </summary>
        </member>
        <member name="M:Engine.Utility.FloatFn.At(System.Single)">
            <summary>
            Returns the value of the function at a given t value
            </summary>
            <param name="t">The point at which the function is being evaluated</param>
            <returns></returns>
        </member>
        <member name="T:Engine.Utility.OscillatingFn">
            <summary>
            Returns values which oscillate on initial + [-mag, mag]
            </summary>
        </member>
        <member name="M:Engine.Utility.OscillatingFn.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Returns values which oscillate on initial + [-mag, mag]
            </summary>
        </member>
        <member name="M:Engine.Utility.OscillatingFn.At(System.Single)">
            <summary>
            Returns the value of the function at a given t value
            </summary>
            <param name="t">The point at which the function is being evaluated</param>
            <returns></returns>
        </member>
        <member name="T:Engine.Utility.DecayFn">
            <summary>
            Returns values of the form initial + mag*e^(-d*t)
            </summary>
        </member>
        <member name="M:Engine.Utility.DecayFn.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Returns values of the form initial + mag*e^(-d*t)
            </summary>
        </member>
        <member name="M:Engine.Utility.DecayFn.At(System.Single)">
            <summary>
            Returns the value of the function at a given t value
            </summary>
            <param name="t">The point at which the function is being evaluated</param>
            <returns></returns>
        </member>
        <member name="T:Engine.Logging.Frequency">
            <summary>
            The expected rate of message writing.
            Can be used to determine how to batch writes
            </summary>
        </member>
        <member name="F:Engine.Logging.Frequency.None">
            <summary>
            Unknown or random frequency
            </summary>
        </member>
        <member name="F:Engine.Logging.Frequency.Low">
            <summary>
            Rarely writing
            </summary>
        </member>
        <member name="F:Engine.Logging.Frequency.Moderate">
            <summary>
            Writing constantly
            </summary>
        </member>
        <member name="F:Engine.Logging.Frequency.High">
            <summary>
            Multiple inputs writing constantly
            </summary>
        </member>
        <member name="F:Engine.Logging.Frequency.Burst">
            <summary>
            Infrequent, high-bandwidth writing
            </summary>
        </member>
        <member name="T:Engine.Logging.Level">
            <summary>
            A log message's severity level
            </summary>
        </member>
        <member name="F:Engine.Logging.Level.Error">
            <summary>
            An error occured
            </summary>
        </member>
        <member name="F:Engine.Logging.Level.Warning">
            <summary>
            A warning
            </summary>
        </member>
        <member name="F:Engine.Logging.Level.Info">
            <summary>
            An informational message
            </summary>
        </member>
        <member name="F:Engine.Logging.Level.Debug">
            <summary>
            Debug information
            </summary>
        </member>
        <member name="T:Engine.Input.Managers.TypedInputManager">
            <summary>
              Manages bindings of keys
            </summary>
        </member>
        <member name="T:Engine.Input.Managers.InputManager">
            <summary>
              Allows input querying and offers hooks for event-driven keyboard input
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InputManager.AddBinding(System.String,Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Add a binding that can be checked for state (Pressed, Released, Active)
            </summary>
            <param name="bindingName"> The string used to query the binding state </param>
            <param name="binding"> The binding to associate with the bindingName </param>
            <param name="player"> The player to add the binding for </param>
            <returns> true if the binding was added </returns>
        </member>
        <member name="M:Engine.Input.Managers.InputManager.RemoveBinding(System.String,Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Remove a binding from the InputManager.  Removes the exact binding from the relation.
              This can be used when you don't know the binding's index in its list of bindings.
            </summary>
            <param name="bindingName"> The string used to query the binding state </param>
            <param name="binding"> The binding to remove from the association with the bindingName </param>
            <param name="player"> The player the binding is being removed for </param>
        </member>
        <member name="M:Engine.Input.Managers.InputManager.ContainsBinding(System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Check if the manager has a binding associated with a bindingName for a player
            </summary>
            <param name="bindingName"> The name of the binding to check for </param>
            <param name="player"> The player to check the binding for </param>
            <returns> True if there are bindings associated with the bindingName for the given player </returns>
        </member>
        <member name="M:Engine.Input.Managers.InputManager.ContainsBinding(Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Check if the manager has a specific binding
            </summary>
            <param name="binding"> The binding to check for </param>
            <param name="player"> The player to check the binding for </param>
            <returns> True if the binding exists for the given player </returns>
        </member>
        <member name="M:Engine.Input.Managers.InputManager.ClearBinding(System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Clears all bindings associated with the given bindingName for a particular player
            </summary>
            <param name="bindingName"> The name of the binding to clear </param>
            <param name="player"> The player to clear the binding for </param>
        </member>
        <member name="M:Engine.Input.Managers.InputManager.ClearAllBindings">
            <summary>
              Clears all bindings for all players
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InputManager.IsActive(System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)">
            <summary>
              Checks if any of the bindings associated with the bindingName for a given player in a given FrameState is active.
            </summary>
            <param name="bindingName"> The name of the binding to query for active state </param>
            <param name="player"> The player to check the binding's activity for </param>
            <param name="state"> The FrameState in which to check for activity </param>
            <returns> True if any of the bindings associated with the bindingName for a given player in a given FrameState is active. </returns>
        </member>
        <member name="M:Engine.Input.Managers.InputManager.GetCurrentBindings(System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Gets the list of bindings associated with a particular bindingName for a given player
            </summary>
            <param name="bindingName"> The bindingName associated with the list of Bindings </param>
            <param name="player"> The player to get the list of bindings for </param>
            <returns> Returns a copy of the Bindings associated with the bindingName for a givem player </returns>
        </member>
        <member name="M:Engine.Input.Managers.InputManager.BindingsUsing(Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Used to get a list of strings that map to the given binding for a given player.
              This is useful when you want to unbind a key from current bindings and remap to a new binding:
              You can present a dialog such as "{key} is currently mapped to {List of Bindings using {key}}.  Are you sure you want to remap {key} to {New binding}?"
            </summary>
            <param name="binding"> The binding to search for in the InputManager </param>
            <param name="player"> The player to search for bindings on </param>
            <returns> A list of the bindingNames that, for a given player, track the given binding as a possible input </returns>
        </member>
        <member name="M:Engine.Input.Managers.InputManager.Update">
            <summary>
              Reads the latest state of the keyboard, mouse, and gamepad. (If polling is enabled for these devices)
            </summary>
            <remarks>
              This should be called at the end of your update loop, so that game logic
              uses latest values.
              Calling update at the beginning of the update loop will clear current buffers (if any) which
              means you will not be able to read the most recent input.
            </remarks>
        </member>
        <member name="P:Engine.Input.Managers.InputManager.GetModifiers">
            <summary>
              All the modifiers currently being tracked.
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.#ctor(Engine.Input.Devices.InputDevice)">
            <summary>
              Constructor
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.#ctor(Engine.Input.Managers.TypedInputManager)">
            <summary>
              Copy Constructor
            </summary>
            <param name="inputManager"> </param>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.AddBinding(System.String,Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Add a binding that can be checked for state (Pressed, Released, Active)
            </summary>
            <param name="bindingName"> The string used to query the binding state </param>
            <param name="binding"> The binding to associate with the bindingName </param>
            <param name="player"> The player to add the binding for </param>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.RemoveBinding(System.String,Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Remove a binding from the InputManager.  Removes the exact binding from the relation.
              This can be used when you don't know the binding's index in its list of bindings.
            </summary>
            <param name="bindingName"> The string used to query the binding state </param>
            <param name="binding"> The binding to remove from the association with the bindingName </param>
            <param name="player"> The player the binding is being removed for </param>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.ContainsBinding(System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Check if the manager has a binding associated with a bindingName for a player
            </summary>
            <param name="bindingName"> The name of the binding to check for </param>
            <param name="player"> The player to check the binding for </param>
            <returns> True if there are bindings associated with the bindingName for the given player </returns>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.ClearBinding(System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Clears all bindings associated with the given bindingName for a particular player
            </summary>
            <param name="bindingName"> The name of the binding to clear </param>
            <param name="player"> The player to clear the binding for </param>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.ClearAllBindings">
            <summary>
              Clears all bindings for all players
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.IsActive(System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)">
            <summary>
              Checks if any of the bindings associated with the bindingName for a given player in a given FrameState is active.
            </summary>
            <param name="bindingName"> The name of the binding to query for active state </param>
            <param name="player"> The player to check the binding's activity for </param>
            <param name="state"> The FrameState in which to check for activity </param>
            <returns> True if any of the bindings associated with the bindingName for a given player in a given FrameState is active. </returns>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.GetCurrentBindings(System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Gets the list of bindings associated with a particular bindingName for a given player
            </summary>
            <param name="bindingName"> The bindingName associated with the list of Bindings </param>
            <param name="player"> The player to get the list of bindings for </param>
            <returns> Returns a copy of the Bindings associated with the bindingName for a givem player </returns>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.BindingsUsing(Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Used to get a list of strings that map to the given binding for a given player.
              This is useful when you want to unbind a key from current bindings and remap to a new binding:
              You can present a dialog such as "{key} is currently mapped to {List of Bindings using {key}}.  Are you sure you want to remap {key} to {New binding}?"
            </summary>
            <param name="binding"> The binding to search for in the InputManager </param>
            <param name="player"> The player to search for bindings on </param>
            <returns> A list of the bindingNames that, for a given player, track the given binding as a possible input </returns>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.Update">
            <summary>
              Reads the latest state of the keyboard, mouse, and gamepad. (If polling is enabled for these devices)
            </summary>
            <remarks>
              This should be called at the end of your update loop, so that game logic
              uses latest values.
              Calling update at the beginning of the update loop will clear current buffers (if any) which
              means you will not be able to read the most recent input.
            </remarks>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.IsModifiersActive(Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.InputSnapshot)">
            <summary>
              Checks if sufficient modifiers are active, as defined by the ModifierCheckType in Settings
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.IsStrictModifiersActive(Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.InputSnapshot)">
            <summary>
              Checks if all (and only all) of the modifiers associated with a binding for a given player were active in the current FrameState (and not in the previous).
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.TypedInputManager.IsSmartModifiersActive(Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.InputSnapshot)">
            <summary>
              Checks if all (and only all) of the modifiers associated with a binding for a given player were active in the current FrameState (and not in the previous).
            </summary>
        </member>
        <member name="P:Engine.Input.Managers.TypedInputManager.Device">
            <summary>
              The device that this manager relies on
            </summary>
        </member>
        <member name="P:Engine.Input.Managers.TypedInputManager.Bindings">
            <summary>
              The Bindings being tracked by the Manager
            </summary>
        </member>
        <member name="P:Engine.Input.Managers.TypedInputManager.Settings">
            <summary>
              The InputSettings for this InputManager (trigger thresholds, etc)
            </summary>
        </member>
        <member name="P:Engine.Input.Managers.TypedInputManager.Modifiers">
            <summary>
              A unique set of modifiers of the bindings this manager tracks.
              Keeps track of how many bindings use this modifier; 
              stops checking for modifiers once no bindings use that modifier
            </summary>
        </member>
        <member name="P:Engine.Input.Managers.TypedInputManager.IsPolling">
            <summary>
              Enable/Disable grabbing device state when updating the manager.
              Disable for performance when you know the user can't use the device, or no bindings will need the state of the device.
            </summary>
        </member>
        <member name="P:Engine.Input.Managers.TypedInputManager.GetModifiers">
            <summary>
              All the modifiers currently being tracked.
            </summary>
        </member>
        <member name="T:Engine.Input.Managers.FullInputManager">
            <summary>
              Manages all types of InputBindings - mouse, keyboard, gamepad.
            </summary>
        </member>
        <member name="T:Engine.Input.EventInput.IKeyboardSubscriber">
            <summary>
            Receives event-driven input in the form of strings, characters, and Keys
            </summary>
        </member>
        <member name="M:Engine.Input.EventInput.IKeyboardSubscriber.ReceiveTextInput(System.Char)">
            <summary>
            Handle a single character of input
            </summary>
            <param name="inputChar"></param>
        </member>
        <member name="M:Engine.Input.EventInput.IKeyboardSubscriber.ReceiveTextInput(System.String)">
            <summary>
            Handle a string of input
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Engine.Input.EventInput.IKeyboardSubscriber.ReceiveCommandInput(System.Char)">
            <summary>
            Handle a special command
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Engine.Input.EventInput.IKeyboardSubscriber.ReceiveSpecialInput(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Handle a Key input
            </summary>
            <param name="key"></param>
        </member>
        <member name="P:Engine.Input.EventInput.IKeyboardSubscriber.Selected">
            <summary>
            Does this Subscriber have the (possibly exclusive) focus
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.FullInputManager.#ctor">
            <summary>
              Constructor
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.FullInputManager.ReceiveTextInput(System.Char)">
            <summary>
              Handle a single character of input
            </summary>
            <param name="inputChar"> </param>
        </member>
        <member name="M:Engine.Input.Managers.FullInputManager.ReceiveTextInput(System.String)">
            <summary>
              Handle a string of input
            </summary>
            <param name="text"> </param>
        </member>
        <member name="M:Engine.Input.Managers.FullInputManager.ReceiveCommandInput(System.Char)">
            <summary>
              Handle a special command
            </summary>
            <param name="command"> </param>
        </member>
        <member name="M:Engine.Input.Managers.FullInputManager.ReceiveSpecialInput(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
              Handle a Key input
            </summary>
            <param name="key"> </param>
        </member>
        <member name="M:Engine.Input.Managers.FullInputManager.Press(System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)">
            <summary>
              "Press" a key in a given frame.
              Cannot press a binding unless it has been added to the InputManager
            </summary>
            <param name="bindingName"> The binding to press </param>
            <param name="player"> The player to press the binding for </param>
            <param name="state"> The frame to press it in </param>
        </member>
        <member name="M:Engine.Input.Managers.FullInputManager.Release(System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)">
            <summary>
              "Release" a key in a given frame.
              Cannot release a binding unless it has been added to the InputManager
            </summary>
            <param name="bindingName"> The binding to release </param>
            <param name="player"> The player to release the binding for </param>
            <param name="state"> The frame to release it in </param>
        </member>
        <member name="M:Engine.Input.Managers.FullInputManager.Initialize(Microsoft.Xna.Framework.GameWindow)">
            <summary>
              Initialize InputManager dependencies (For event-driven input)
            </summary>
            <param name="window"> </param>
        </member>
        <member name="M:Engine.Input.Managers.FullInputManager.GetBufferedText">
            <summary>
              The buffered text input since the last frame.  This is cleared per frame,
              regardless of whether it has been read.
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.FullInputManager.GetMousePosition(Engine.Input.FrameState)">
            <summary>
              Get the position of the mouse in the specified frame.
            </summary>
            <param name="state"> The frame to inspect for the position- the current frame or the previous frame </param>
            <returns> The position of the mouse in screen space </returns>
        </member>
        <member name="P:Engine.Input.Managers.FullInputManager.ModifierCheckType">
            <summary>
              How the manager checks modifiers
            </summary>
        </member>
        <member name="P:Engine.Input.Managers.FullInputManager.Selected">
            <summary>
              Does this Subscriber have the (possibly exclusive) focus
            </summary>
        </member>
        <member name="P:Engine.Input.Managers.FullInputManager.GetModifiers">
            <summary>
              All the modifiers currently being tracked.
            </summary>
        </member>
        <member name="T:Engine.Input.InputBinding">
            <summary>
              A Binding for input that can be checked for activity, using states for the keyboard, mouse, and gamepads.
            </summary>
        </member>
        <member name="M:Engine.Input.InputBinding.IsActive(Engine.Input.InputSnapshot)">
            <summary>
              True if the InputBinding is active in the given FrameState of the given InputManager
            </summary>
        </member>
        <member name="M:Engine.Input.InputBinding.IsEqual(Engine.Input.InputBinding,System.Boolean)">
            <summary>
              Compares this Binding to another, and returns whether they are the same (with/without modifiers)
            </summary>
        </member>
        <member name="P:Engine.Input.InputBinding.Modifiers">
            <summary>
              Returns the list of modifiers necessary to be active before the binding is considered "active"
            </summary>
        </member>
        <member name="T:Engine.Events.GameObjectEvents.GameObjectDestroyedEvent">
            <summary>
            Event when a GameObject is destroyed
            </summary>
        </member>
        <member name="T:Engine.Events.GameEvent">
            <summary>
            An event fired relating to some change in game state.
            Can be used for signaling changes in state, units,
            environment, etc
            </summary>
        </member>
        <member name="F:Engine.Events.GameEvent.src">
            <summary>
            The firing GameObject (may be null)
            </summary>
        </member>
        <member name="F:Engine.Events.GameEvent.dst">
            <summary>
            The receiving GameObject (may be null)
            </summary>
        </member>
        <member name="F:Engine.Events.GameEvent.args">
            <summary>
            Any arguments related to the event
            </summary>
        </member>
        <member name="M:Engine.Events.GameEvent.#ctor(Engine.Entities.GameObject,Engine.Entities.GameObject,Engine.Events.GameEventArgs,System.Single)">
            <summary>
            Construct a GameEvent that will be fired after timeToSend has elapsed
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="args"></param>
            <param name="timeToSend"></param>
        </member>
        <member name="M:Engine.Events.GameEvent.Update(System.Single)">
            <summary>
            Update the GameEvent, and fire it if the elapsed time since creation
            is >= timeToSend
            </summary>
            <param name="dt"></param>
        </member>
        <member name="P:Engine.Events.GameEvent.HasFired">
            <summary>
            Whether or not the event has been fired
            (at least once)
            </summary>
        </member>
        <member name="M:Engine.Events.GameObjectEvents.GameObjectDestroyedEvent.#ctor(Engine.Entities.GameObject)">
            <summary>
            Construct an event when a GameObject is destroyed.
            It is not required that object destruction fire an event
            </summary>
            <param name="src"></param>
        </member>
        <member name="P:Engine.Events.GameObjectEvents.GameObjectDestroyedEvent.GameObject">
            <summary>
            The GameObject destroyed
            </summary>
        </member>
        <member name="T:Engine.DataStructures.DefaultDict`2">
            <summary>
            Uses TryGetValue for index-notation lookup
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Engine.DataStructures.DefaultDict`2.#ctor">
            <summary>
            Construct a DefaultDict whose fallback value is the public parameterless constructor of TValue
            </summary>
        </member>
        <member name="M:Engine.DataStructures.DefaultDict`2.#ctor(System.Func{`1})">
            <summary>
            Construct a DefaultDict whose fallback value is generated by the given function
            </summary>
        </member>
        <member name="M:Engine.DataStructures.DefaultDict`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Construct a DefaultDict from another IDict, with a fallback value function that is the
            public parameterless constructor of TVale
            </summary>
        </member>
        <member name="M:Engine.DataStructures.DefaultDict`2.#ctor(Engine.DataStructures.DefaultDict{`0,`1})">
            <summary>
            Copy Constructor - copies the other DefaultDict's defaultValueFunc
            </summary>
            <param name="other"></param>
        </member>
        <member name="P:Engine.DataStructures.DefaultDict`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <returns></returns>
        </member>
        <member name="T:Engine.DataStructures.DefaultObjDict`2">
            <summary>
            Uses TryGetValue for index-notation lookup
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Engine.DataStructures.DefaultObjDict`2.#ctor">
            <summary>
            Construct a DefaultDict whose fallback value is the public parameterless constructor of TValue
            </summary>
        </member>
        <member name="M:Engine.DataStructures.DefaultObjDict`2.#ctor(System.Func{`1})">
            <summary>
            Construct a DefaultDict whose fallback value is generated by the given function
            </summary>
        </member>
        <member name="M:Engine.DataStructures.DefaultObjDict`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Construct a DefaultDict from another IDict, with a fallback value function that is the
            public parameterless constructor of TVale
            </summary>
        </member>
        <member name="M:Engine.DataStructures.DefaultObjDict`2.#ctor(Engine.DataStructures.DefaultObjDict{`0,`1})">
            <summary>
            Copy Constructor - copies the other DefaultDict's defaultValueFunc
            </summary>
            <param name="other"></param>
        </member>
        <member name="P:Engine.DataStructures.DefaultObjDict`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <returns></returns>
        </member>
        <member name="T:Engine.Utility.StructExtensions">
            <summary>
            Extensions for common operations like full-array copying
            </summary>
        </member>
        <member name="M:Engine.Utility.StructExtensions.Copy``1(``0[])">
            <summary>
            Returns a copy of the entirety of the source array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:Engine.Utility.GraphicsDeviceExtensions">
            <summary>
            Extensions for easily creating RenderTargets and the like
            </summary>
        </member>
        <member name="M:Engine.Utility.GraphicsDeviceExtensions.CreateFullscreenRenderTarget(Microsoft.Xna.Framework.Graphics.GraphicsDevice,System.Boolean)">
            <summary>
            Because this method takes a boolean, it will never pass a RenderTargetUsage of PlatformContents,
            only PreserveContents or DiscardContents.
            </summary>
            <param name="graphicsDevice"></param>
            <param name="preserveContents"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Utility.GraphicsDeviceExtensions.CreateFullscreenRenderTarget(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Graphics.RenderTargetUsage)">
            <summary>
            Create a RenderTarget with a given RenderTargetUsage
            </summary>
            <param name="graphicsDevice"></param>
            <param name="renderTargetUsage"></param>
            <returns></returns>
        </member>
        <member name="T:Engine.Events.GameEventArgs">
            <summary>
            The arguments of a GameEvent
            </summary>
        </member>
        <member name="M:Engine.Events.GameEventArgs.#ctor">
            <summary>
            Empty GameEvent
            </summary>
        </member>
        <member name="M:Engine.Events.GameEventArgs.#ctor(System.String)">
            <summary>
            GameEvent with a given message
            </summary>
            <param name="msg"></param>
        </member>
        <member name="P:Engine.Events.GameEventArgs.msg">
            <summary>
            Message describing the event or providing additional metadata
            </summary>
        </member>
        <member name="T:Engine.Entities.Hostility">
            <summary>
            Describes the hostility relation between GameObject(s)
            </summary>
        </member>
        <member name="F:Engine.Entities.Hostility.None">
            <summary>
            There is no defined relation between the object(s)
            </summary>
        </member>
        <member name="F:Engine.Entities.Hostility.Any">
            <summary>
            All relations apply between the object(s)
            </summary>
        </member>
        <member name="F:Engine.Entities.Hostility.Player">
            <summary>
            The object(s) are player controlled or can be considered part of the player
            </summary>
        </member>
        <member name="F:Engine.Entities.Hostility.Friend">
            <summary>
            The object(s) are friendly with each other
            </summary>
        </member>
        <member name="F:Engine.Entities.Hostility.Neutral">
            <summary>
            The object(s) are neutral with each other
            </summary>
        </member>
        <member name="F:Engine.Entities.Hostility.Unfriendly">
            <summary>
            The object(s) are unfriendly with each other
            </summary>
        </member>
        <member name="T:Engine.Input.Devices.KeyboardDevice">
            <summary>
              Tracks keyboard state
            </summary>
        </member>
        <member name="T:Engine.Input.Devices.InputDevice">
            <summary>
              Wrapper around different devices, loads info into a snapshot.
            </summary>
        </member>
        <member name="M:Engine.Input.Devices.InputDevice.Update">
            <summary>
              Update the device
            </summary>
        </member>
        <member name="M:Engine.Input.Devices.InputDevice.GetDeviceSnapshot(Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)">
            <summary>
              Returns a (likely partial) snapshot of the device(s) for a given player
            </summary>
            <returns> </returns>
        </member>
        <member name="M:Engine.Input.Devices.KeyboardDevice.Update">
            <summary>
              See <see cref="M:Engine.Input.Devices.InputDevice.Update"/>
            </summary>
        </member>
        <member name="M:Engine.Input.Devices.KeyboardDevice.GetDeviceSnapshot(Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)">
            <summary>
              See <see cref="M:Engine.Input.Devices.InputDevice.GetDeviceSnapshot(Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)"/>
            </summary>
        </member>
        <member name="P:Engine.Input.Devices.KeyboardDevice.PreviousKeyboardState">
            <summary>
              KeyboardState for the previous frame
            </summary>
        </member>
        <member name="P:Engine.Input.Devices.KeyboardDevice.CurrentKeyboardState">
            <summary>
              KeyboardState for the current frame
            </summary>
        </member>
        <member name="T:Engine.Input.Devices.MouseDevice">
            <summary>
              Tracks mouse state
            </summary>
        </member>
        <member name="M:Engine.Input.Devices.MouseDevice.Update">
            <summary>
              See <see cref="M:Engine.Input.Devices.InputDevice.Update"/>
            </summary>
        </member>
        <member name="M:Engine.Input.Devices.MouseDevice.GetDeviceSnapshot(Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)">
            <summary>
              See <see cref="M:Engine.Input.Devices.InputDevice.GetDeviceSnapshot(Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)"/>
            </summary>
        </member>
        <member name="P:Engine.Input.Devices.MouseDevice.PreviousMouseState">
            <summary>
              MouseState for the previous frame
            </summary>
        </member>
        <member name="P:Engine.Input.Devices.MouseDevice.CurrentMouseState">
            <summary>
              MouseState for the current frame
            </summary>
        </member>
        <member name="T:Engine.Input.Devices.GamePadDevice">
            <summary>
              Tracks GamePad states
            </summary>
        </member>
        <member name="M:Engine.Input.Devices.GamePadDevice.Update">
            <summary>
              See <see cref="M:Engine.Input.Devices.InputDevice.Update"/>
            </summary>
        </member>
        <member name="M:Engine.Input.Devices.GamePadDevice.GetDeviceSnapshot(Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)">
            <summary>
              See <see cref="M:Engine.Input.Devices.InputDevice.GetDeviceSnapshot(Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)"/>
            </summary>
        </member>
        <member name="P:Engine.Input.Devices.GamePadDevice.PreviousGamePadStates">
            <summary>
              GamePadState for the previous frame
            </summary>
        </member>
        <member name="P:Engine.Input.Devices.GamePadDevice.CurrentGamePadStates">
            <summary>
              GamePadState for the current frame
            </summary>
        </member>
        <member name="T:Engine.Events.EventWatchers.IEventWatcher">
            <summary>
            Watches events and reacts to them.
            
            Can respond to events when they are created, when they're fired, when they die, etc...
            </summary>
        </member>
        <member name="M:Engine.Events.EventWatchers.IEventWatcher.GetWatchTiming">
            <summary>
            The time in an even'ts life which the watcher is interested in
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.Events.EventWatchers.IEventWatcher.InspectEvent(Engine.Events.GameEvent)">
            <summary>
            Inspect an event and possibly react to it.
            </summary>
            <param name="gameEvent"></param>
        </member>
        <member name="T:Engine.DataStructures.CountedCollection`1">
            <summary>
              Provides an iterable set of unique entries.
              Adding an item increases the count of that item by 1.
              Removing an item decreases the count by 1.
              When the count is zero, the value is removed from the set.
            
              The iterator is over unique values
            </summary>
            <typeparam name="T"> </typeparam>
        </member>
        <member name="M:Engine.DataStructures.CountedCollection`1.#ctor">
            <summary>
              Construct an empty CountedSet
            </summary>
        </member>
        <member name="M:Engine.DataStructures.CountedCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
              Copy the values of an enumerable into a CountedSet.
              Note that duplicates will increment the count, and are not included in the iterable set twice.
            </summary>
            <param name="enumerable"> </param>
        </member>
        <member name="M:Engine.DataStructures.CountedCollection`1.#ctor(Engine.DataStructures.CountedCollection{`0})">
            <summary>
              Copy the values of another counted set, as well as the count for each item.
            </summary>
            <param name="countedSet"> </param>
        </member>
        <member name="M:Engine.DataStructures.CountedCollection`1.Merge(Engine.DataStructures.CountedCollection{`0})">
            <summary>
            Merges the values of other into this collection, including their counts
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Engine.DataStructures.CountedCollection`1.Add(`0)">
            <summary>
              See ICollection.Add
            </summary>
        </member>
        <member name="M:Engine.DataStructures.CountedCollection`1.Clear">
            <summary>
              See ICollection.Clear
            </summary>
        </member>
        <member name="M:Engine.DataStructures.CountedCollection`1.Contains(`0)">
            <summary>
              See ICollection.Contains
            </summary>
        </member>
        <member name="M:Engine.DataStructures.CountedCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
              See ICollection.CopyTo
            </summary>
        </member>
        <member name="M:Engine.DataStructures.CountedCollection`1.Remove(`0)">
            <summary>
              See ICollection.Remove
            </summary>
        </member>
        <member name="P:Engine.DataStructures.CountedCollection`1.Count">
            <summary>
              See ICollection.Count
            </summary>
        </member>
        <member name="P:Engine.DataStructures.CountedCollection`1.IsReadOnly">
            <summary>
              See ICollection.IsReadOnly
            </summary>
        </member>
        <member name="T:Engine.Camera.Effects.CameraEffect">
            <summary>
            Modifies the position, scale, or rotation of a camera.
            Care should be taken that a CameraEffect never lets net scale = 0
            </summary>
        </member>
        <member name="F:Engine.Camera.Effects.CameraEffect.camera">
            <summary>
            The Camera the effect is being applied to
            </summary>
        </member>
        <member name="F:Engine.Camera.Effects.CameraEffect.elapsed">
            <summary>
            Elapsed time in seconds of the effect
            </summary>
        </member>
        <member name="F:Engine.Camera.Effects.CameraEffect.dur">
            <summary>
            Duration in seconds of the effect
            </summary>
        </member>
        <member name="M:Engine.Camera.Effects.CameraEffect.#ctor(Engine.Camera.Camera,System.Single)">
            <summary>
            Construct a camera effect on the target camera for dur seconds
            </summary>
            <param name="camera"></param>
            <param name="dur"></param>
        </member>
        <member name="M:Engine.Camera.Effects.CameraEffect.Update(System.Single)">
            <summary>
            Update the camera effect - elapsed time may be incremented past duration
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:Engine.Camera.Effects.CameraEffect.Reset">
            <summary>
            Reset the camera effect to its original state
            </summary>
        </member>
        <member name="M:Engine.Camera.Effects.CameraEffect.End">
            <summary>
            End the camera effect immediately.
            </summary>
        </member>
        <member name="M:Engine.Camera.Effects.CameraEffect.offsetX">
            <summary>
            x pos offset of the camera caused by the effect
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.Camera.Effects.CameraEffect.offsetY">
            <summary>
            y pos offset of the camera caused by the effect
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.Camera.Effects.CameraEffect.scaleX">
            <summary>
            Always multiply by camera scale so that we don't hit a scale of 0.
            Original equation was scale *= (1 + offsetScale)
            New equation is scale += offsetScale
            We can keep the functionality by multiplying by camera scale in this equation
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.Camera.Effects.CameraEffect.scaleY">
            <summary>
            Always multiply by camera scale so that we don't hit a scale of 0.
            Original equation was scale *= (1 + offsetScale)
            New equation is scale += offsetScale
            We can keep the functionality by multiplying by camera scale in this equation
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.Camera.Effects.CameraEffect.rotation">
            <summary>
            Rotation of the camera caused by the effect
            </summary>
            <returns></returns>
        </member>
        <member name="P:Engine.Camera.Effects.CameraEffect.t">
            <summary>
            Percent of effect elapsed- t in [0, 1]
            </summary>
        </member>
        <member name="P:Engine.Camera.Effects.CameraEffect.IsActive">
            <summary>
            True if 0 &lt; dur &lt;= elapsed
            </summary>
        </member>
        <member name="P:Engine.Camera.Effects.CameraEffect.Offsets">
            <summary>
            Returns the offsets used in calculating the camera transform matrix
            </summary>
        </member>
        <member name="T:Engine.Utility.StringAndRegexExtensions">
            <summary>
              Adds a few handy methods for dealing with strings and regex
            </summary>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.MatchNamedCaptures(System.Text.RegularExpressions.Regex,System.String)">
            <summary>
              Returns a Dictionary&lt;CapturingGroupName, CapturedGroupValue&gt;
              of the regex of the input string
            </summary>
            <param name="regex"> </param>
            <param name="input"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.HasNamedCapture(System.Text.RegularExpressions.Regex,System.String,System.String)">
            <summary>
              Checks if the regex has a named group for the given input string
            </summary>
            <param name="regex"> </param>
            <param name="input"> </param>
            <param name="groupname"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.GetNamedCapture(System.Text.RegularExpressions.Regex,System.String,System.String)">
            <summary>
              If the regex has a named group for the given input string, returns the value of that groupname.
              Otherwise, returns null.
            </summary>
            <param name="regex"> </param>
            <param name="input"> </param>
            <param name="groupname"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.ReadLines(System.String)">
            <summary>
              Generator that yields each line of a file
            </summary>
            <param name="file"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
              Takes an enumerable and returns the string such that each element is printed,
              separated by the given separator.
            </summary>
            <typeparam name="T"> </typeparam>
            <param name="enumerable"> </param>
            <param name="separator"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.TrimEnd(System.String,System.String)">
            <summary>
              Removes any occurrences of the character sequence trim from the end of the string.
              Uses repeated substring and assignment - do not use for heavy lifting.
            </summary>
            <param name="source"> </param>
            <param name="trim"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.format(System.String,System.Object[])">
            <summary>
              Returns the formatted string.  Lowercase because there's already a static method with this signature
            </summary>
            <param name="str"> </param>
            <param name="args"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.Timestamped(System.String,System.String)">
            <summary>
              Returns the string prepended with the time in the format:
              "HH:mm:ffff "
            </summary>
            <param name="str"> </param>
            <param name="time_fmt"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.ByteCount(System.String,System.Text.Encoding)">
            <summary>
              Gets the byte count of the string in the given encoding
            </summary>
            <param name="str"> </param>
            <param name="encoding"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.GetBytes(System.String,System.Text.Encoding)">
            <summary>
              Get the bytes of a string in a given encoding
            </summary>
            <param name="str"> </param>
            <param name="encoding"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.GetBytesUTF8(System.String)">
            <summary>
              bytes of a UTF8-encoded string
            </summary>
            <param name="str"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.Utility.StringAndRegexExtensions.Until(System.String,System.Char)">
            <summary>
              Returns the substring from the beginning until the first occurance of the character c.
              Returns the whole string if that character isn't found.
            </summary>
        </member>
        <member name="T:Engine.Utility.DictionaryExtensions">
            <summary>
            Extensions for manipulating dictionaries, such as merging
            </summary>
        </member>
        <member name="M:Engine.Utility.DictionaryExtensions.Merge``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1}[])">
            <summary>
            Merges any number of dictionaries into a new one.
            Values in the new dictionary are overwritten left to right,
            such that order matters. (The dictionary this is performed on is the base,
            so any key that it shares with another dictionary will be overwritten)
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dictionary"></param>
            <param name="others"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Utility.DictionaryExtensions.Remove``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0)">
            <summary>
            When you're removing from a concurrent dictionary and you don't care if the value is successfully removed
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
        </member>
        <member name="T:Engine.Tiles.Chunk`1">
            <summary>
            A section of items that can be loaded from or saved to disk
            (or another resource, such as a network connection)
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Engine.Tiles.Chunk`1.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a chunk whose top left corner is at x, y and with dimensions width x height
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:Engine.Tiles.Chunk`1.#ctor(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Create a chunk whose top left corner is at position, with the given dimensions
            </summary>
            <param name="position"></param>
            <param name="dimensions"></param>
        </member>
        <member name="M:Engine.Tiles.Chunk`1.UpdateTile(Microsoft.Xna.Framework.Point,`0)">
            <summary>
            Update the value of a single tile.
            Location is local to the chunk coordinates
            </summary>
            <param name="localTilePosition">Position of the tile in chunk's coordinates</param>
            <param name="value">New value for the tile to take</param>
        </member>
        <member name="M:Engine.Tiles.Chunk`1.LoadData(`0[],System.Int32)">
            <summary>
            Loads data from an array into the chunk.
            Note that while this won't necessarily fill all data in the chunk,
            it will flag the chunk as loaded.
            </summary>
            <param name="data"></param>
            <param name="startIndex"></param>
        </member>
        <member name="M:Engine.Tiles.Chunk`1.ClearData">
            <summary>
            Clears the chunk's data.
            Note that this does not actually null the values,
            so the chunk can be used again by a tile manager.
            Do not read values from a chunk after it has been cleared
            until all of the values have been read over using LoadData
            </summary>
        </member>
        <member name="M:Engine.Tiles.Chunk`1.SetGlobalPosition(Microsoft.Xna.Framework.Point)">
            <summary>
            Set the chunk's global position.  This is the position of the upper-left tile in the chunk.
            </summary>
            <param name="position"></param>
        </member>
        <member name="M:Engine.Tiles.Chunk`1.GetLocalPosition(Microsoft.Xna.Framework.Point)">
            <summary>
            Calculates the local position of a tile in the chunk given its global location
            </summary>
            <param name="globalTilePosition"></param>
            <returns>The local coordinates of the tile in the chunk, or null if the tile is not in the chunk</returns>
        </member>
        <member name="M:Engine.Tiles.Chunk`1.GetGlobalPosition(Microsoft.Xna.Framework.Point)">
            <summary>
            Calculates the global position of a tile in the world given its local chunk location
            </summary>
            <param name="localTilePosition"></param>
            <returns>The global coordinates of the tile in the world</returns>
        </member>
        <member name="P:Engine.Tiles.Chunk`1.Tiles">
            <summary>
            The values of the tiles in the chunk
            </summary>
        </member>
        <member name="P:Engine.Tiles.Chunk`1.Item(System.Int32,System.Int32)">
            <summary>
            Set or Get a tile's value at the given local coordinates.
            
            </summary>
            <param name="x">Local Chunk x-coordinate</param>
            <param name="y">Local Chunk y-coordinate</param>
            <returns></returns>
        </member>
        <member name="P:Engine.Tiles.Chunk`1.GlobalPosition">
            <summary>
            The global position of the upper-left-most tile in the chunk
            </summary>
        </member>
        <member name="P:Engine.Tiles.Chunk`1.Dimensions">
            <summary>
            Width and Height of the chunk
            </summary>
        </member>
        <member name="P:Engine.Tiles.Chunk`1.IsLoaded">
            <summary>
            Whether or not the values loaded in the chunk are valid.
            False when the chunk has been cleared, or is partially loaded.
            </summary>
        </member>
        <member name="T:Engine.Rendering.ColorScheme`1">
            <summary>
            Maps LayerTypes and <typeparamref name="T"/>s to Colors.
            </summary>
            <typeparam name="T">The type which maps to Colors for a certain LayerType</typeparam>
        </member>
        <member name="T:Engine.DataStructures.MultiKeyObjDict`3">
            <summary>
              A DefaultDict that supports two keys.
            </summary>
            <typeparam name="TKey1"> The first key type </typeparam>
            <typeparam name="TKey2"> The second key type </typeparam>
            <typeparam name="TValue"> The value type stored in the dictionary </typeparam>
        </member>
        <member name="M:Engine.DataStructures.MultiKeyObjDict`3.#ctor">
            <summary>
              Construct an empty Double-keyed dictionary
            </summary>
        </member>
        <member name="M:Engine.DataStructures.MultiKeyObjDict`3.#ctor(Engine.DataStructures.MultiKeyObjDict{`0,`1,`2})">
            <summary>
              Copy Constructor
            </summary>
            <param name="defaultMultiKeyDict"> </param>
        </member>
        <member name="M:Engine.DataStructures.MultiKeyObjDict`3.Clear">
            <summary>
              Clear all values from the DefaultMultiKeyDict
            </summary>
        </member>
        <member name="P:Engine.DataStructures.MultiKeyObjDict`3.Item(`0,`1)">
            <summary>
              Gets or sets the value associated with the specified keys.
            </summary>
            <param name="key1"> The first key of the value to get or set. </param>
            <param name="key2"> The second key of the value to get or set. </param>
            <returns> </returns>
        </member>
        <member name="P:Engine.DataStructures.MultiKeyObjDict`3.Keys">
            <summary>
              Gets a collection containing the keys in the Engine.Utility.DefaultMultiKeyDict&lt;TKey1, TKey2, TValue&gt;.
            </summary>
        </member>
        <member name="M:Engine.Rendering.ColorScheme`1.#ctor">
            <summary>
            Create an empty ColorScheme mapping
            </summary>
        </member>
        <member name="M:Engine.Rendering.ColorScheme`1.#ctor(Engine.Rendering.ColorScheme{`0})">
            <summary>
            Copy Constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Engine.Rendering.ColorScheme`1.LoadFromFile(System.String,System.String)">
            <summary>
            Load a color scheme from a file
            </summary>
            <param name="filename">Location of the color scheme file</param>
            <param name="profilename">The profile to load from the color scheme file</param>
        </member>
        <member name="M:Engine.Rendering.ColorScheme`1.SaveToFile(System.String,System.String)">
            <summary>
            Save a color scheme to a file
            </summary>
            <param name="filename">Location to save the color scheme file</param>
            <param name="profilename">The profile to save the color scheme as, in the file</param>
        </member>
        <member name="T:Engine.Networking.IServer">
            <summary>
            Receives and Sends messages, handles Connect/Disconnect and Auth
            </summary>
        </member>
        <member name="M:Engine.Networking.IServer.Start">
            <summary>
            Start the server.  Until the server is started, it cannot handle messages
            Cannot be started after Shutdown
            </summary>
        </member>
        <member name="M:Engine.Networking.IServer.Stop">
            <summary>
            Stop handling messages.
            Can be resumed with Start
            </summary>
        </member>
        <member name="M:Engine.Networking.IServer.Shutdown(System.Boolean)">
            <summary>
            Completely release all clients and stop handling messages.
            Cannot be started after a shutdown.
            Sends a shutdown message to clients unless immediate is true
            </summary>
            <param name="immediate"></param>
        </member>
        <member name="M:Engine.Networking.IServer.Connect(Engine.Networking.Client,Engine.Networking.ServerEventArgs)">
            <summary>
            Tries to connect a client to the Server.
            Fires OnConnect, even if client does not successfully connect
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:Engine.Networking.IServer.Disconnect(Engine.Networking.Client,Engine.Networking.ServerEventArgs)">
            <summary>
            Tries to disconnect a client to the Server.
            Fires OnDisconnect, even if client does not successfully disconnect
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:Engine.Networking.IServer.Authenticate(Engine.Networking.Client,Engine.Networking.ServerEventArgs)">
            <summary>
            Tries to authenticate a client.
            Fires OnAuthenticate, even if client does not successfully authenticate
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:Engine.Networking.IServer.ReceivePacket(Engine.Networking.Packets.Packet,Engine.Networking.Client)">
            <summary>
            Receives a packet from a client
            </summary>
            <param name="packet"></param>
            <param name="client"></param>
        </member>
        <member name="M:Engine.Networking.IServer.SendPacket(Engine.Networking.Packets.Packet,Engine.Networking.Client[])">
            <summary>
            Sends a packet to a specific group of clients.
            Sends to all connected clients if the list is empty
            </summary>
            <param name="packet"></param>
            <param name="client"></param>
        </member>
        <member name="M:Engine.Networking.IServer.IsAuthenticated(Engine.Networking.Client)">
            <summary>
            Checks if the client has authenticated with the server,
            and if that authentication is still valid
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Networking.IServer.GetClientString(Engine.Networking.Client)">
            <summary>
            Gets the string that uniquely identifies the client
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Networking.IServer.GetClient(System.String)">
            <summary>
            Gets a client from a given string that uniquely identifies the client
            </summary>
            <param name="clientString"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Networking.IServer.GetClientStrings(Engine.Networking.Client[])">
            <summary>
            Gets the strings that uniquely identify the clients
            </summary>
            <param name="clients"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Networking.IServer.GetClients(System.String[])">
            <summary>
            Gets the clients from the given strings that uniquely identify the clients
            </summary>
            <param name="clientStrings"></param>
            <returns></returns>
        </member>
        <member name="P:Engine.Networking.IServer.IsRunning">
            <summary>
            If the server has been started, returns true.
            Returns false if the server is stopped or shutdown.
            A server cannot be started from shutdown.
            </summary>
        </member>
        <member name="E:Engine.Networking.IServer.OnStart">
            <summary>
            Fired when the server is started
            </summary>
        </member>
        <member name="E:Engine.Networking.IServer.OnStop">
            <summary>
            Fired when the server is stopped
            </summary>
        </member>
        <member name="E:Engine.Networking.IServer.OnShutdown">
            <summary>
            Fired when the server is shut down
            </summary>
        </member>
        <member name="E:Engine.Networking.IServer.OnConnect">
            <summary>
            Fired when a client attempts to connect to the server
            </summary>
        </member>
        <member name="E:Engine.Networking.IServer.OnDisconnect">
            <summary>
            Fired when a client attempts to disconnect to the server
            </summary>
        </member>
        <member name="E:Engine.Networking.IServer.OnAuthenticate">
            <summary>
            Fired when a client attempts to authenticate
            </summary>
        </member>
        <member name="T:Engine.Networking.Packets.ChatPacket">
            <summary>
            A packet containing fields for a message and who the message is to and from
            </summary>
        </member>
        <member name="T:Engine.Networking.Packets.Packet">
            <summary>
            Wrapper around the byte array that is sent to/read from a network stream
            </summary>
        </member>
        <member name="F:Engine.Networking.Packets.Packet.string_fmt">
            <summary>
            Formats a string to be null-terminated
            </summary>
        </member>
        <member name="M:Engine.Networking.Packets.Packet.LoadFromBuffer(System.Byte[])">
            <summary>
            Load the data from a buffer according to the packet type's
            specification.  Buffer includes the four bytes that specify the type
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:Engine.Networking.Packets.Packet.Parse(System.Byte[])">
            <summary>
            Parses the packet type based on its first four bytes
            and returns an instance of that packet type with its appropriate values loaded.
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Networking.Packets.Packet.fromInt(System.Int32)">
            <summary>
            Helper method for getting the byte array of an int
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Networking.Packets.Packet.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to this one
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Engine.Networking.Packets.Packet.ByteStream">
            <summary>
            Constructs and returns the byte array that represents the packet
            </summary>
        </member>
        <member name="P:Engine.Networking.Packets.Packet.EmptyPacket">
            <summary>
            A packet with no body, and type code 0
            </summary>
        </member>
        <member name="M:Engine.Networking.Packets.Packet.NullPacket.LoadFromBuffer(System.Byte[])">
            <summary>
            An empty packet does not load any data
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="P:Engine.Networking.Packets.Packet.NullPacket.ByteStream">
            <summary>
            Empty except for type code of 0
            </summary>
        </member>
        <member name="M:Engine.Networking.Packets.ChatPacket.LoadFromBuffer(System.Byte[])">
            <summary>
            See <see cref="M:Engine.Networking.Packets.Packet.LoadFromBuffer(System.Byte[])"/>
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="P:Engine.Networking.Packets.ChatPacket.Message">
            <summary>
            The message being sent
            </summary>
        </member>
        <member name="P:Engine.Networking.Packets.ChatPacket.From">
            <summary>
            Who the message is from
            </summary>
        </member>
        <member name="P:Engine.Networking.Packets.ChatPacket.To">
            <summary>
            Who the message is to
            </summary>
        </member>
        <member name="P:Engine.Networking.Packets.ChatPacket.ByteStream">
            <summary>
            See <see cref="P:Engine.Networking.Packets.Packet.ByteStream"/>
            </summary>
        </member>
        <member name="T:Engine.Entities.GameObject">
            <summary>
            An object that exists in the game.
            Consists of components which are managed by component systems.
            Most interaction should be handled by passing and receiving appropriate messages,
                but can be handled directly using the Touch(GameObject other) method.
            </summary>
        </member>
        <member name="M:Engine.Entities.GameObject.#ctor(Engine.Events.GameEventManager)">
            <summary>
            Create a deactived GameObject with 0 health, and fire a GameObjectCreatedEvent
            </summary>
            <param name="manager">The manager which will fire the GameObjectCreatedEvent</param>
        </member>
        <member name="M:Engine.Entities.GameObject.#ctor(Engine.Events.GameEventManager,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Create a GameObject with a certain amount of health, possible active, and
            can fire a GameObjectCreatedEvent
            </summary>
            <param name="manager">The manager which will fire the GameObjectCreatedEvent</param>
            <param name="health"></param>
            <param name="active"></param>
            <param name="fireOnCreateEvent"></param>
        </member>
        <member name="M:Engine.Entities.GameObject.#ctor(Engine.Entities.GameObject,System.Boolean)">
            <summary>
            Copy another Gameobject.  Optionally fire a GameObjectCreatedEvent
            </summary>
            <param name="other"></param>
            <param name="fireOnCreateEvent"></param>
        </member>
        <member name="M:Engine.Entities.GameObject.AddBehavior(Engine.Entities.Behaviors.IBehavior)">
            <summary>
            Adds a behavior to the GameObject
            </summary>
            <param name="behavior"></param>
        </member>
        <member name="M:Engine.Entities.GameObject.RemoveBehavior(Engine.Entities.Behaviors.IBehavior)">
            <summary>
            Removes a behavior from the GameObject
            </summary>
            <param name="behavior"></param>
        </member>
        <member name="M:Engine.Entities.GameObject.UpdateBehaviors(System.Single)">
            <summary>
            Update all behaviors the GameObject has,
            and applies those behaviors to this object
            if it meets the behavior's criteria
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:Engine.Entities.GameObject.OnGameEvent(Engine.Entities.GameObject,Engine.Events.GameEventArgs)">
            <summary>
            Handle a GameEvent from a GameObject (can be self)
            </summary>
            <param name="src"></param>
            <param name="args"></param>
        </member>
        <member name="M:Engine.Entities.GameObject.Update(System.Single)">
            <summary>
            Update any logic and behaviors
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:Engine.Entities.GameObject.Draw(Microsoft.Xna.Framework.Graphics.SpriteBatch,Engine.Rendering.RenderPass)">
            <summary>
            Draw a certain pass of the GameObject using a given SpriteBatch
            </summary>
            <param name="batch"></param>
            <param name="pass"></param>
        </member>
        <member name="M:Engine.Entities.GameObject.Touch(Engine.Entities.GameObject)">
            <summary>
            Touch the GameObject with another
            </summary>
            <param name="other"></param>
            <returns>True if the objects interact</returns>
        </member>
        <member name="M:Engine.Entities.GameObject.Destroy(System.Boolean,System.Boolean)">
            <summary>
            Destroy the GameObject.  Can be used in cleanup and can fire GameObjectDestroyedEvents
            </summary>
            <param name="isCleanup">This object is being destroyed as part of a cleanup step</param>
            <param name="fireOnDestroyEvent">The GameObject should signal that is is being destroyed</param>
        </member>
        <member name="P:Engine.Entities.GameObject.ColorScheme">
            <summary>
            The RenderLayer and Hostility-based ColorScheme used to render the GameObject.
            </summary>
        </member>
        <member name="P:Engine.Entities.GameObject.GameEventManager">
            <summary>
            The GameEventManager to send events to.
            A singleton is not used, in case some groups of objects broadcast general
            messages that would be misinterpreted by supersets of their object group
            </summary>
        </member>
        <member name="P:Engine.Entities.GameObject.PhysicsComponent">
            <summary>
            The PhysicsComponent which controls the GameObject's motion
            </summary>
        </member>
        <member name="P:Engine.Entities.GameObject.Behaviors">
            <summary>
            Any behaviors the GameObject has (not necessarily active or for which the GameObject meets all criteria)
            </summary>
        </member>
        <member name="P:Engine.Entities.GameObject.Active">
            <summary>
            Whether or not the GameObject is active.  Non-active objects are not necessarily dead, however)
            </summary>
        </member>
        <member name="P:Engine.Entities.GameObject.Timescale">
            <summary>
            The ratio of elapsed time for this unit compared to the time delta it is given.
            </summary>
            /// <example>
            For a unit with Timescale 2.0, things happen twice as fast - energy regen, attack rate, etc
            </example>
        </member>
        <member name="P:Engine.Entities.GameObject.Health">
            <summary>
            The unit's health.  &lt;= 0 does not necessarily indicate dead or non-active
            </summary>
        </member>
        <member name="T:Engine.Entities.Behaviors.IBehavior">
            <summary>
            A behavior which can be applied to a GameObject if another GameObject meets the
            Behavior's criteria.  Note that the GameObjects being checked and applied can be the same.
            </summary>
        </member>
        <member name="M:Engine.Entities.Behaviors.IBehavior.Apply(Engine.Entities.GameObject)">
            <summary>
            Apply the Behavior to a GameObject.
            This method assumes that the behavior's criteria have been met
            </summary>
            <param name="gameObject"></param>
        </member>
        <member name="M:Engine.Entities.Behaviors.IBehavior.Destroy">
            <summary>
            Destroy the Behavior
            </summary>
        </member>
        <member name="M:Engine.Entities.Behaviors.IBehavior.MeetsCriteria(Engine.Entities.GameObject)">
            <summary>
            Whether or not a given GameObject meets this Behavior's criteria
            </summary>
            <param name="gameObject"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Entities.Behaviors.IBehavior.Update(System.Single)">
            <summary>
            Updates any temporal data the Behavior tracks, which can be used when
            checking critera or applying the behavior.  Behaviors do not necessarily
            use this information.
            </summary>
            <param name="dt"></param>
        </member>
        <member name="P:Engine.Entities.Behaviors.IBehavior.Enabled">
            <summary>
            Set/Get the state of the Behavior.
            Enabled should be checked before applying a Behavior,
            but such a check isn't strictly required.
            </summary>
        </member>
        <member name="T:Engine.Utility.Vector2Extensions">
            <summary>
            Adds a few handy Vector methods, such as "AsAngle" and "RotateAbout"
            </summary>
        </member>
        <member name="M:Engine.Utility.Vector2Extensions.AsAngle(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Returns the angle of the vector, counter-clockwise from +x
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Utility.Vector2Extensions.Copy(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Returns a copy of the vector
            </summary>
            <param name="other">The vector to copy</param>
            <returns></returns>
        </member>
        <member name="M:Engine.Utility.Vector2Extensions.RotateAbout(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Returns a Vector2 of the given vector rotated about an origin, by an angle theta (in raidans)
            </summary>
            <param name="vector">The vector to rotate</param>
            <param name="origin">The point that the given vector is rotated about</param>
            <param name="theta">The angle (in radians) to rotate by</param>
            <returns></returns>
        </member>
        <member name="T:Engine.Rendering.RenderPass">
            <summary>
            Specify which stage of rendering is occuring
            </summary>
        </member>
        <member name="F:Engine.Rendering.RenderPass.None">
            <summary>
            Nothing happens in this RenderPass (or, an unknown state)
            </summary>
        </member>
        <member name="F:Engine.Rendering.RenderPass.Background">
            <summary>
            Background items are being rendered
            </summary>
        </member>
        <member name="F:Engine.Rendering.RenderPass.PreEffect">
            <summary>
            Just before main special effects are applied
            </summary>
        </member>
        <member name="F:Engine.Rendering.RenderPass.Effects">
            <summary>
            Any special effects that aren't fullscreen post happen here
            </summary>
        </member>
        <member name="F:Engine.Rendering.RenderPass.PostEffect">
            <summary>
            Anything that happens after effects are applied
            </summary>
        </member>
        <member name="F:Engine.Rendering.RenderPass.PrePostProcessing">
            <summary>
            Just before fullscreen postprocessing happens
            </summary>
        </member>
        <member name="F:Engine.Rendering.RenderPass.Post">
            <summary>
            Postprocessing - blur, bloom, etc
            </summary>
        </member>
        <member name="F:Engine.Rendering.RenderPass.UI">
            <summary>
            Any UI rendered on top of the game world which shouldn't be touched by
            postprocessing.  Note that it's fine for UI to have its own effects, but
            they may be applied to the game rendering as well (depending on how your
            pipeline is configured)
            </summary>
        </member>
        <member name="F:Engine.Rendering.RenderPass.Debug">
            <summary>
            Anything that should be rendered while debugging
            </summary>
        </member>
        <member name="T:Engine.Rendering.LayerType">
            <summary>
            Draw layer type for an object
            </summary>
        </member>
        <member name="F:Engine.Rendering.LayerType.None">
            <summary>
            A noop layer, or a layer when one is unknown
            </summary>
        </member>
        <member name="F:Engine.Rendering.LayerType.Base">
            <summary>
            Basic rendering layer
            </summary>
        </member>
        <member name="F:Engine.Rendering.LayerType.Highlight">
            <summary>
            Any rendering done on top of the base
            </summary>
        </member>
        <member name="T:Engine.Events.GameObjectEvents.GameObjectCreatedEvent">
            <summary>
            Event when a GameObject is created
            </summary>
        </member>
        <member name="M:Engine.Events.GameObjectEvents.GameObjectCreatedEvent.#ctor(Engine.Entities.GameObject)">
            <summary>
            Construct an event when a GameObject is created.
            It is not required that object creation fire an event
            </summary>
            <param name="src"></param>
        </member>
        <member name="P:Engine.Events.GameObjectEvents.GameObjectCreatedEvent.GameObject">
            <summary>
            The GameObject created
            </summary>
        </member>
        <member name="T:Engine.Camera.CameraMode">
            <summary>
            The modes that a camera can be in.
            
            LockedPos     :: Locked to a single Vector2, does not move
            LockedTarget  :: Locked to a single GameObject, tracks the center of the screen to GameObject.Position
            VtTTransition :: Vector -> GameObject Transition.  Moving from a LockedPos to LockedTarget
            TtVTransition :: GameObject -> Vector Transition.  Moving from a LockedTarget to LockedPos
            TtTTransition :: GameObject -> GameObject Transition.  Moving from one LockedPos to another
            VtVTransition :: Vector -> Vector Transition.  Moving from one LockedPos to another
            </summary>
        </member>
        <member name="F:Engine.Camera.CameraMode.LockedPos">
            <summary>
            Locked to a single position
            </summary>
        </member>
        <member name="F:Engine.Camera.CameraMode.LockedTarget">
            <summary>
            Locked to a single GameObject, following that object's position
            </summary>
        </member>
        <member name="F:Engine.Camera.CameraMode.VtTTransition">
            <summary>
            Transitioning from a fixed position to tracking a GameObject
            </summary>
        </member>
        <member name="F:Engine.Camera.CameraMode.TtVTransition">
            <summary>
            Transitioning from tracking a GameObject to a fixed position
            </summary>
        </member>
        <member name="F:Engine.Camera.CameraMode.TtTTransition">
            <summary>
            Transitioning from a fixed position to a different fixed position
            </summary>
        </member>
        <member name="F:Engine.Camera.CameraMode.VtVTransition">
            <summary>
            Transitioning from tracking a GameObject to tracking a different GameObject
            </summary>
        </member>
        <member name="T:Engine.Networking.Client">
            <summary>
            Attempts to abstract the network layer of the TcpClient,
            so that this is simply a read/write container.
            Manages concurrent read/writes using ConcurrentQueues
            </summary>
        </member>
        <member name="M:Engine.Networking.Client.#ctor(System.Net.Sockets.TcpClient,System.Boolean)">
            <summary>
            Construct a client that manages concurrent reads/writes to a TcpClient
            Default behavior starts the client immediately
            </summary>
            <param name="baseClient"></param>
            <param name="start"></param>
        </member>
        <member name="M:Engine.Networking.Client.Write(System.Byte[])">
            <summary>
            Writes a message to the client.
            Messages are queued and a thread proccesses them in the order they were enqueued
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:Engine.Networking.Client.WritePacket(Engine.Networking.Packets.Packet)">
            <summary>
            Writes a packet to the client.
            Messages are queued and a thread proccesses them in the order they were enqueued
            </summary>
            <param name="packet"></param>
        </member>
        <member name="M:Engine.Networking.Client.Read">
            <summary>
            Tries to read a message from the client.
            Returns null if there is no pending message from the client.
            Messages to be read are enqueued by a worker thread and added in the order they are received
            </summary>
        </member>
        <member name="M:Engine.Networking.Client.ReadPacket">
            <summary>
            Tries to read a message from the client.
            Returns an empty packet if there is no pending message from the client.
            Messages to be read are enqueued by a worker thread and added in the order they are received
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.Networking.Client.Start">
            <summary>
            Start reading/writing
            </summary>
        </member>
        <member name="M:Engine.Networking.Client.Close">
            <summary>
            Close the TcpClient and its underlying NetworkStream
            </summary>
        </member>
        <member name="P:Engine.Networking.Client.TcpClient">
            <summary>
            Underlying TcpClient
            </summary>
        </member>
        <member name="P:Engine.Networking.Client.HasQueuedReadMessages">
            <summary>
            Whether there are pending messages to be read.
            </summary>
        </member>
        <member name="P:Engine.Networking.Client.IsAlive">
            <summary>
            Whether the underlying TcpClient is still alive,
            and handling reads/writes
            </summary>
        </member>
        <member name="P:Engine.Networking.Client.IPString">
            <summary>
            Returns the underlying TcpClient's IPAddress as a string
            </summary>
        </member>
        <member name="T:Engine.Logging.ILog">
            <summary>
            Logging interface
            </summary>
        </member>
        <member name="M:Engine.Logging.ILog.Debug(System.String)">
            <summary>
            Log a debug message
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Engine.Logging.ILog.Error(System.String)">
            <summary>
            Log an error message
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Engine.Logging.ILog.Info(System.String)">
            <summary>
            Log an info message
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Engine.Logging.ILog.Warn(System.String)">
            <summary>
            Log a warning message
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:Engine.Input.Managers.AddBindings.InputManagerAddBindingExtensions">
            <summary>
              Shortcut methods for adding various specific input bindings
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.AddBindings.InputManagerAddBindingExtensions.AddBinding(Engine.Input.Managers.InputManager,System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.ThumbstickDirection,Engine.Input.Thumbstick,Engine.Input.InputBinding[])">
            <summary>
              Add a ThumbstickDirection binding that can be checked for state (Pressed, Released, Active)
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.AddBindings.InputManagerAddBindingExtensions.AddBinding(Engine.Input.Managers.InputManager,System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.MouseButton,Engine.Input.InputBinding[])">
            <summary>
              Add a MouseButton binding that can be checked for state (Pressed, Released, Active)
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.AddBindings.InputManagerAddBindingExtensions.AddBinding(Engine.Input.Managers.InputManager,System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.Thumbstick,Engine.Input.InputBinding[])">
            <summary>
              Add a Thumbstick binding that can be checked for state (Pressed, Released, Active)
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.AddBindings.InputManagerAddBindingExtensions.AddBinding(Engine.Input.Managers.InputManager,System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.Trigger,Engine.Input.InputBinding[])">
            <summary>
              Add a Trigger binding that can be checked for state (Pressed, Released, Active)
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.AddBindings.InputManagerAddBindingExtensions.AddBinding(Engine.Input.Managers.InputManager,System.String,Microsoft.Xna.Framework.PlayerIndex,Microsoft.Xna.Framework.Input.Buttons,Engine.Input.InputBinding[])">
            <summary>
              Add a Button binding that can be checked for state (Pressed, Released, Active)
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.AddBindings.InputManagerAddBindingExtensions.AddBinding(Engine.Input.Managers.InputManager,System.String,Microsoft.Xna.Framework.PlayerIndex,Microsoft.Xna.Framework.Input.Keys,Engine.Input.InputBinding[])">
            <summary>
              Add a key binding that can be checked for state (Pressed, Released, Active)
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.AddBindings.InputManagerAddBindingExtensions.IsPressed(Engine.Input.Managers.InputManager,System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Checks if any of the bindings associated with the bindingName for a given player was pressed in the current FrameState (and not in the previous).
            </summary>
            <param name="bindingName"> The name of the binding to query for active state </param>
            <param name="player"> The player to check the binding's activity for </param>
            <returns> True if any of the bindings associated with the bindingName for a given player was pressed in the current FrameState (and not in the previous). </returns>
        </member>
        <member name="M:Engine.Input.Managers.AddBindings.InputManagerAddBindingExtensions.IsReleased(Engine.Input.Managers.InputManager,System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Checks if any of the bindings associated with the bindingName for a given player was released in the current FrameState (and not in the previous).
            </summary>
            <param name="bindingName"> The name of the binding to query for active state </param>
            <param name="player"> The player to check the binding's activity for </param>
            <returns> True if any of the bindings associated with the bindingName for a given player was released in the current FrameState (and not in the previous). </returns>
        </member>
        <member name="M:Engine.Input.InputManagerExtensions.IsPressed(Engine.Input.Managers.InputManager,System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Checks if any of the bindings associated with the bindingName for a given player was pressed in the current FrameState (and not in the previous).
            </summary>
            <param name="bindingName"> The name of the binding to query for active state </param>
            <param name="player"> The player to check the binding's activity for </param>
            <returns> True if any of the bindings associated with the bindingName for a given player was pressed in the current FrameState (and not in the previous). </returns>
        </member>
        <member name="M:Engine.Input.InputManagerExtensions.IsReleased(Engine.Input.Managers.InputManager,System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Checks if any of the bindings associated with the bindingName for a given player was released in the current FrameState (and not in the previous).
            </summary>
            <param name="bindingName"> The name of the binding to query for active state </param>
            <param name="player"> The player to check the binding's activity for </param>
            <returns> True if any of the bindings associated with the bindingName for a given player was released in the current FrameState (and not in the previous). </returns>
        </member>
        <member name="T:Engine.Rendering.Pipeline.IRenderEffect">
            <summary>
            Renders an effect on a preEffect texture, out to a postEffect texture.
            preEffect texture is unmodified, unless preEffect texture is postEffect texture
            </summary>
        </member>
        <member name="M:Engine.Rendering.Pipeline.IRenderEffect.LoadContent(Microsoft.Xna.Framework.Content.ContentManager,Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Load any required content the effect requires for rendering
            </summary>
            <param name="contentManager"></param>
            <param name="graphicsDevice"></param>
            <param name="spriteBatch"></param>
        </member>
        <member name="M:Engine.Rendering.Pipeline.IRenderEffect.UnloadContent">
            <summary>
            Free up resources when you don't need to render bloom effects anymore.
            </summary>
        </member>
        <member name="M:Engine.Rendering.Pipeline.IRenderEffect.ApplyEffect(Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Graphics.RenderTarget2D)">
            <summary>
            Renders the results of the effect on the preEffectTexture to the postEffectTexture.
            (preEffectTexture unmodified unless pre == post)
            </summary>
            <param name="preEffectTexture"></param>
            <param name="postEffectTexture"></param>
        </member>
        <member name="M:Engine.Rendering.Pipeline.IRenderEffect.Reset">
            <summary>
            Reset any state the effect might track, such as camera deltas or elapsed game time
            </summary>
        </member>
        <member name="T:Engine.Rendering.Effects.BloomSettings">
            <summary>
            Class holds all the settings used to tweak the bloom effect.
            </summary>
        </member>
        <member name="F:Engine.Rendering.Effects.BloomSettings.Name">
            <summary>
            Name of a preset bloom setting, for display to the user.
            </summary>
        </member>
        <member name="F:Engine.Rendering.Effects.BloomSettings.BloomThreshold">
            <summary>
            Controls how bright a pixel needs to be before it will bloom.
            Zero makes everything bloom equally, while higher values select
            only brighter colors. Somewhere between 0.25 and 0.5 is good.
            </summary>
        </member>
        <member name="F:Engine.Rendering.Effects.BloomSettings.BlurAmount">
            <summary>
            Controls how much blurring is applied to the bloom image.
            The typical range is from 1 up to 10 or so.
            </summary>
        </member>
        <member name="F:Engine.Rendering.Effects.BloomSettings.BloomIntensity">
            <summary>
            Controls the amount of the bloom and base images that
            will be mixed into the final scene. Range 0 to 1.
            </summary>
        </member>
        <member name="F:Engine.Rendering.Effects.BloomSettings.BaseIntensity">
            <summary>
            Controls the amount of the bloom and base images that
            will be mixed into the final scene. Range 0 to 1.
            </summary>
        </member>
        <member name="F:Engine.Rendering.Effects.BloomSettings.BloomSaturation">
            <summary>
            Independently control the color saturation of the bloom and
            base images. Zero is totally desaturated, 1.0 leaves saturation
            unchanged, while higher values increase the saturation level.
            </summary>
        </member>
        <member name="F:Engine.Rendering.Effects.BloomSettings.BaseSaturation">
            <summary>
            Independently control the color saturation of the bloom and
            base images. Zero is totally desaturated, 1.0 leaves saturation
            unchanged, while higher values increase the saturation level.
            </summary>
        </member>
        <member name="M:Engine.Rendering.Effects.BloomSettings.#ctor(System.String,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs a new bloom settings descriptor.
            </summary>
        </member>
        <member name="F:Engine.Rendering.Effects.BloomSettings.PresetSettings">
            <summary>
            Table of preset bloom settings, used by the sample program.
            </summary>
        </member>
        <member name="T:Engine.Events.GameEventManager">
            <summary>
            Manages and dispatches game events, and
            notifies any interested watchers
            </summary>
        </member>
        <member name="F:Engine.Events.GameEventManager.isUpdating">
            <summary>
            Used to make sure we don't try to add events to the queue as we're processing it.
            </summary>
        </member>
        <member name="F:Engine.Events.GameEventManager.events">
            <summary>
            Events tracked by the Manager
            </summary>
        </member>
        <member name="F:Engine.Events.GameEventManager.queuedEvents">
            <summary>
            Events added during the update loop that should be processed
            </summary>
        </member>
        <member name="F:Engine.Events.GameEventManager.completedEvents">
            <summary>
            Events that have fired and can be removed from the manager at the end of the update loop
            </summary>
        </member>
        <member name="F:Engine.Events.GameEventManager.watchers">
            <summary>
            Watchers that should be notified of different event states (Create, Fire)
            </summary>
        </member>
        <member name="M:Engine.Events.GameEventManager.#ctor">
            <summary>
            Create a default GameEventManager
            </summary>
        </member>
        <member name="M:Engine.Events.GameEventManager.AddEvent(Engine.Events.GameEvent)">
            <summary>
            Add an event to the manager.  If called during an update loop, the event will be added to the list of
            queued events, and will be updated with a time delta of 0 at the end of the current loop.
            </summary>
            <param name="gameEvent"></param>
        </member>
        <member name="M:Engine.Events.GameEventManager.RemoveEvent(Engine.Events.GameEvent)">
            <summary>
            Remove an event from the Manager
            </summary>
            <param name="gameEvent"></param>
        </member>
        <member name="M:Engine.Events.GameEventManager.AddWatcher(Engine.Events.EventWatchers.IEventWatcher)">
            <summary>
            Add a watcher to the manager
            </summary>
            <param name="watcher"></param>
        </member>
        <member name="M:Engine.Events.GameEventManager.RemoveWatcher(Engine.Events.EventWatchers.IEventWatcher)">
            <summary>
            Remove a watcher from the manager
            </summary>
            <param name="watcher"></param>
        </member>
        <member name="M:Engine.Events.GameEventManager.Update(System.Single)">
            <summary>
            Update the manager, updating any tracked events, firing any that need to, and removing fired events
            </summary>
            <param name="dt"></param>
        </member>
        <member name="P:Engine.Events.GameEventManager.GlobalEventManager">
            <summary>
            A default GameEventManager.  Its use is discouraged
            except for those things which are guaranteed to only ever
            happen in one context (such as game state changes between menus, etc)
            </summary>
        </member>
        <member name="T:Engine.Utility.ThreadExtensions">
            <summary>
            Extensions for thread actions
            </summary>
        </member>
        <member name="M:Engine.Utility.ThreadExtensions.Kill(System.Threading.Thread,System.Int32)">
            <summary>
            Abort a thread if it doesn't join n milliseconds after an interrupt.
            </summary>
            <param name="thread"></param>
            <param name="millisecondsTimeout"></param>
        </member>
        <member name="T:Engine.Input.InputSettings">
            <summary>
            A set of limits and thresholds that some bindings must pass to be considered active
            </summary>
        </member>
        <member name="F:Engine.Input.InputSettings.TriggerThreshold">
            <summary>
            The minimum value for a trigger to register as 'pulled'
            </summary>
        </member>
        <member name="F:Engine.Input.InputSettings.ThumbstickThreshold">
            <summary>
            The minimum value for a thumbstick (not necessarily magnitude) to register as 'pushed'
            </summary>
        </member>
        <member name="F:Engine.Input.InputSettings.ModifierCheckType">
            <summary>
              How a binding's modifiers are validated against the manager state.
              See <see cref="F:Engine.Input.InputSettings.ModifierCheckType"/> for more info.
            </summary>
        </member>
        <member name="M:Engine.Input.InputSettings.#ctor(System.Single,System.Single,Engine.Input.ModifierCheckType)">
            <summary>
            Construct a set of Input Settings describing certain thresholds and limits that must be met for
            some bindings to be considered "active"
            </summary>
            <param name="triggerThreshold">The minimum value a trigger must have to be considered pulled/depressed (active)</param>
            <param name="thumbstickThreshold">The minimum value a thumbstick must be moved to be considered active 
            (some bindings may require this amount in a single direction)</param>
            <param name="modifierCheckType">How modifiers are checked</param>
        </member>
        <member name="M:Engine.Input.InputSettings.#ctor(Engine.Input.InputSettings)">
            <summary>
            Copy Constructor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="T:Engine.DataStructures.DoubleBuffer`1">
            <summary>
            Provides Push, Flip, and full Front inspection.
            Does not support Pop or buffer folding (extend front with back instead of swapping and clearing)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Engine.DataStructures.DoubleBuffer`1.#ctor">
            <summary>
            Construct an empty DoubleBuffer
            </summary>
        </member>
        <member name="M:Engine.DataStructures.DoubleBuffer`1.Flip">
            <summary>
            Flip Front and Back buffers
            </summary>
        </member>
        <member name="M:Engine.DataStructures.DoubleBuffer`1.Push(`0)">
            <summary>
            Push a value onto the back buffer
            </summary>
            <param name="item">The item to push</param>
        </member>
        <member name="P:Engine.DataStructures.DoubleBuffer`1.Front">
            <summary>
            The current Front buffer.  Cannot be written to.
            </summary>
        </member>
        <member name="P:Engine.DataStructures.DoubleBuffer`1.Back">
            <summary>
            The current Back buffer.  Can be written to.
            </summary>
        </member>
        <member name="P:Engine.DataStructures.DoubleBuffer`1.BackBufferSize">
            <summary>
            Returns the number of items currently in the back buffer
            </summary>
        </member>
        <member name="T:Engine.DataStructures.CycleBuffer`2">
            <summary>
            A cyclic buffer - cycling will move the values in Current into Previous,
            and clear the Current buffer.
            Both buffers can be written to and inspected at any time.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`2.#ctor(`0,`0)">
            <summary>
            Construct a CycleBuffer with the given current/previous keys
            </summary>
            <param name="keyCurrent"></param>
            <param name="keyPrevious"></param>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`2.#ctor(Engine.DataStructures.CycleBuffer{`0,`1})">
            <summary>
            Copy Constructor
            </summary>
            <param name="cycleBuffer"></param>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`2.Add(`0,`1)">
            <summary>
            Add a value to one of the buffers
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`2.Clear">
            <summary>
            Clear both buffers
            </summary>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`2.Cycle">
            <summary>
            Move current values to previous and clear current
            </summary>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`2.Remove(`0,`1)">
            <summary>
            Remove a value from one of the buffers
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="P:Engine.DataStructures.CycleBuffer`2.Previous">
            <summary>
            Previous values (will be cleared on next Cycle)
            </summary>
        </member>
        <member name="P:Engine.DataStructures.CycleBuffer`2.Current">
            <summary>
            Current values (will be moved to Previous on next Cycle)
            </summary>
        </member>
        <member name="P:Engine.DataStructures.CycleBuffer`2.Item(`0)">
            <summary>
            Returns the requested buffer
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:Engine.DataStructures.CycleBuffer`3">
            <summary>
            A cyclic buffer - cycling will move the values in Current into Previous,
            and clear the Current buffer.
            Both buffers can be written to and inspected at any time.
            </summary>
            <typeparam name="TBufferKey"></typeparam>
            <typeparam name="TBufferInnerKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`3.#ctor(`0,`0)">
            <summary>
            Construct a CycleBuffer with the given current/previous keys
            </summary>
            <param name="keyCurrent"></param>
            <param name="keyPrevious"></param>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`3.#ctor(Engine.DataStructures.CycleBuffer{`0,`1,`2})">
            <summary>
            Copy Constructor
            </summary>
            <param name="cycleBuffer"></param>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`3.Add(`0,`1,`2)">
            <summary>
            Add a value to one of the buffers
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="value"></param>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`3.Clear">
            <summary>
            Clear both buffers
            </summary>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`3.Cycle">
            <summary>
            Move current values to previous and clear current
            </summary>
        </member>
        <member name="M:Engine.DataStructures.CycleBuffer`3.Remove(`0,`1,`2)">
            <summary>
            Remove a value from one of the buffers
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="value"></param>
        </member>
        <member name="P:Engine.DataStructures.CycleBuffer`3.Previous">
            <summary>
            Previous values (will be cleared on next Cycle)
            </summary>
        </member>
        <member name="P:Engine.DataStructures.CycleBuffer`3.Current">
            <summary>
            Current values (will be moved to Previous on next Cycle)
            </summary>
        </member>
        <member name="P:Engine.DataStructures.CycleBuffer`3.Item(`0,`1)">
            <summary>
            Returns the requested buffer
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <returns></returns>
        </member>
        <member name="T:Engine.Utility.IterableExtensions">
            <summary>
              Extensions for generic Iterables
            </summary>
        </member>
        <member name="M:Engine.Utility.IterableExtensions.Combinations``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
              Return r-length subsequences of elements from the input iterable.
              Combinations are emitted in lexicographic sort order.
              Elements are treated as unique based on their position, not on their value.
            </summary>
            <example>
              'ABCD'.Combinations(2) --> AB AC AD BC BD CD
            </example>
        </member>
        <member name="M:Engine.Utility.IterableExtensions.ListCombinations``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
              Return r-length subsequences (as lists) of elements from the input iterable.
              Combinations are emitted in lexicographic sort order.
              Elements are treated as unique based on their position, not on their value.
            </summary>
            <example>
              'ABCD'.Combinations(2) --> AB AC AD BC BD CD
            </example>
        </member>
        <member name="T:Engine.Globals">
            <summary>
            Variables useful for enumeration and compatability
            across various systems
            </summary>
        </member>
        <member name="F:Engine.Globals.Players">
            <summary>
            Provides an in-order [1-4] list of PlayerIndex for loops
            </summary>
        </member>
        <member name="T:Engine.Rendering.Pipeline.PixelShaderPipeline">
            <summary>
            Basic pipeline for rendering effects using pixel shaders
            </summary>
        </member>
        <member name="F:Engine.Rendering.Pipeline.PixelShaderPipeline.RenderTarget">
            <summary>
            The current RenderTarget2D based on which pass the PostPipeline is in
            </summary>
        </member>
        <member name="M:Engine.Rendering.Pipeline.PixelShaderPipeline.#ctor(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Game)">
            <summary>
            Basic PixelShaderPipeline
            </summary>
            <param name="graphicsDevice"></param>
            <param name="game"></param>
        </member>
        <member name="M:Engine.Rendering.Pipeline.PixelShaderPipeline.LoadContent">
            <summary>
            Load the pipeline's content
            </summary>
        </member>
        <member name="M:Engine.Rendering.Pipeline.PixelShaderPipeline.UnloadContent">
            <summary>
            Unload the pipeline's content, 
            and the content of any effects in the pipeline
            </summary>
        </member>
        <member name="M:Engine.Rendering.Pipeline.PixelShaderPipeline.Clear(Microsoft.Xna.Framework.Color)">
            <summary>
            Clear the screens, set background color
            </summary>
        </member>
        <member name="M:Engine.Rendering.Pipeline.PixelShaderPipeline.Draw">
            <summary>
            Draw everything to the screen
            </summary>
        </member>
        <member name="M:Engine.Rendering.Pipeline.PixelShaderPipeline.AddRenderEffect(Engine.Rendering.Pipeline.IRenderEffect)">
            <summary>
            Append a rendering effect to the pipeline
            and load the effect's content
            </summary>
            <param name="effect">The effect to be added</param>
        </member>
        <member name="M:Engine.Rendering.Pipeline.PixelShaderPipeline.RemoveRenderEffect(Engine.Rendering.Pipeline.IRenderEffect)">
            <summary>
            Remove a rendering effect from the pipeline
            Unloads that effect's content
            </summary>
            <param name="effect"></param>
        </member>
        <member name="P:Engine.Rendering.Pipeline.PixelShaderPipeline.Passes">
            <summary>
            Array of render passes for iteration
            </summary>
        </member>
        <member name="P:Engine.Rendering.Pipeline.PixelShaderPipeline.RenderPass">
            <summary>
            Which RenderPass the RenderPipeline is currently processing.
            Changing this value will trigger at least one render target switch.
            </summary>
        </member>
        <member name="T:Engine.Networking.Packets.ServerInfoPacket">
            <summary>
            Contains info about the server, such as IP address and server name
            </summary>
        </member>
        <member name="M:Engine.Networking.Packets.ServerInfoPacket.LoadFromBuffer(System.Byte[])">
            <summary>
            See <see cref="M:Engine.Networking.Packets.Packet.LoadFromBuffer(System.Byte[])"/>
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="P:Engine.Networking.Packets.ServerInfoPacket.IP">
            <summary>
            Server IP
            </summary>
        </member>
        <member name="P:Engine.Networking.Packets.ServerInfoPacket.Name">
            <summary>
            Name of the server
            </summary>
        </member>
        <member name="P:Engine.Networking.Packets.ServerInfoPacket.Description">
            <summary>
            Description of the server's capabilities, rules, etc
            </summary>
        </member>
        <member name="P:Engine.Networking.Packets.ServerInfoPacket.Port">
            <summary>
            Port the server sends/receives on
            </summary>
        </member>
        <member name="P:Engine.Networking.Packets.ServerInfoPacket.CurrentPlayers">
            <summary>
            Current players connected (or taking up player slots, whatever that means for a server
            </summary>
        </member>
        <member name="P:Engine.Networking.Packets.ServerInfoPacket.MaxPlayers">
            <summary>
            Maximum player slots or connections
            </summary>
        </member>
        <member name="P:Engine.Networking.Packets.ServerInfoPacket.HasPassword">
            <summary>
            Whether the server requires a password
            </summary>
        </member>
        <member name="P:Engine.Networking.Packets.ServerInfoPacket.ByteStream">
            <summary>
            See <see cref="P:Engine.Networking.Packets.Packet.ByteStream"/>
            </summary>
        </member>
        <member name="T:Engine.Entities.Behaviors.PrimitiveSteeringBehavior">
            <summary>
            Always updates the PhysicsComponent's rotation to align with the object's velocity
            </summary>
        </member>
        <member name="T:Engine.Utility.NetworkingExtensions">
            <summary>
            Extensions for networking stuff
            </summary>
        </member>
        <member name="M:Engine.Utility.NetworkingExtensions.GetIP(System.Net.Sockets.TcpClient)">
            <summary>
            Gets the IPAddress of the client as a string
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Utility.NetworkingExtensions.ReadExact(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Attempts to read exactly count bytes into the buffer, starting at offset.
            Throws EOS Exception when the requested number of bytes aren't read
            </summary>
        </member>
        <member name="M:Engine.Utility.NetworkingExtensions.ReadWithHeader(System.IO.Stream)">
            <summary>
            Reads a message from a stream where the first 4 bytes are the size of the rest of the message
            </summary>
        </member>
        <member name="M:Engine.Utility.NetworkingExtensions.ReadStringWithHeader(System.IO.Stream)">
            <summary>
            Reads a message from a stream where the first 4 bytes are the size of the rest of the message
            </summary>
        </member>
        <member name="M:Engine.Utility.NetworkingExtensions.WriteWithHeader(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a message to the stream, prepending a fixed size header (4 bytes) which describes the size of the rest of the message
            </summary>
        </member>
        <member name="M:Engine.Utility.NetworkingExtensions.WriteWithHeader(System.IO.Stream,System.String)">
            <summary>
            Writes a message to the stream, prepending a fixed size header (4 bytes) which describes the size of the rest of the message
            </summary>
        </member>
        <member name="T:Engine.Rendering.Effects.BloomEffect">
            <summary>
            The classic bloom effect.  Use sparingly.
            </summary>
        </member>
        <member name="T:Engine.Rendering.Pipeline.RenderEffect">
            <summary>
            Renders an effect on a preEffect texture, out to a postEffect texture.
            preEffect texture is unmodified, unless preEffect texture is postEffect texture
            </summary>
        </member>
        <member name="F:Engine.Rendering.Pipeline.RenderEffect.graphicsDevice">
            <summary>
            Used for switching render targets and drawing full-quad effects
            </summary>
        </member>
        <member name="M:Engine.Rendering.Pipeline.RenderEffect.LoadContent(Microsoft.Xna.Framework.Content.ContentManager,Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Load any required content the effect requires for rendering
            </summary>
            <param name="contentManager"></param>
            <param name="graphicsDevice"></param>
            <param name="spriteBatch"></param>
        </member>
        <member name="M:Engine.Rendering.Pipeline.RenderEffect.UnloadContent">
            <summary>
            Free up resources when you don't need to render bloom effects anymore.
            </summary>
        </member>
        <member name="M:Engine.Rendering.Pipeline.RenderEffect.ApplyEffect(Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Graphics.RenderTarget2D)">
            <summary>
            Renders the results of the effect on the preEffectTexture to the postEffectTexture.
            (preEffectTexture unmodified unless pre == post)
            </summary>
            <param name="preEffectTexture"></param>
            <param name="postEffectTexture"></param>
        </member>
        <member name="M:Engine.Rendering.Pipeline.RenderEffect.Reset">
            <summary>
            Reset any state the effect might track, such as camera deltas or elapsed game time
            </summary>
        </member>
        <member name="M:Engine.Rendering.Pipeline.RenderEffect.DrawFullscreenQuad(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.Effect)">
            <summary>
            Draw a texture to the renderTarget using a particular BlendState and Effect
            </summary>
            <param name="texture"></param>
            <param name="renderTarget"></param>
            <param name="blendState"></param>
            <param name="effect"></param>
        </member>
        <member name="M:Engine.Rendering.Pipeline.RenderEffect.DrawFullscreenQuad(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Graphics.BlendState,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.Effect)">
            <summary>
            Draw a texture to a widthxheight section of the current RenderTarget using a particular BlendState and Effect
            </summary>
            <param name="texture"></param>
            <param name="blendState"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="effect"></param>
        </member>
        <member name="P:Engine.Rendering.Pipeline.RenderEffect.None">
            <summary>
            A RenderEffect which does nothing
            </summary>
        </member>
        <member name="M:Engine.Rendering.Pipeline.RenderEffect.EmptyRenderEffect.ApplyEffect(Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Graphics.RenderTarget2D)">
            <summary>
            Renders the results of the effect on the preEffectTexture to the postEffectTexture.
            (preEffectTexture unmodified unless pre == post)
            </summary>
            <param name="preEffectTexture"></param>
            <param name="postEffectTexture"></param>
        </member>
        <member name="F:Engine.Rendering.Effects.BloomEffect.Settings">
            <summary>
            The settings that control how much bling your screen has
            </summary>
        </member>
        <member name="M:Engine.Rendering.Effects.BloomEffect.#ctor">
            <summary>
            Default Bloom effect, subtle and clean
            </summary>
        </member>
        <member name="M:Engine.Rendering.Effects.BloomEffect.#ctor(Engine.Rendering.Effects.BloomSettings)">
            <summary>
            Set up your own Bloom effect based on a set of BloomSettings
            </summary>
            <param name="bloomSettings"></param>
        </member>
        <member name="M:Engine.Rendering.Effects.BloomEffect.LoadContent(Microsoft.Xna.Framework.Content.ContentManager,Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Load any required content the effect requires for rendering
            </summary>
            <param name="contentManager"></param>
            <param name="graphicsDevice"></param>
            <param name="spriteBatch"></param>
        </member>
        <member name="M:Engine.Rendering.Effects.BloomEffect.UnloadContent">
            <summary>
            Free up resources when you don't need to render bloom effects anymore.
            </summary>
        </member>
        <member name="M:Engine.Rendering.Effects.BloomEffect.ApplyEffect(Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Graphics.RenderTarget2D)">
            <summary>
            Renders the results of the effect on the preEffectTexture to the postEffectTexture.
            (preEffectTexture unmodified unless pre == post)
            </summary>
            <param name="preEffectTexture"></param>
            <param name="postEffectTexture"></param>
        </member>
        <member name="M:Engine.Rendering.Effects.BloomEffect.SetBlurEffectParameters(System.Single,System.Single)">
            <summary>
            Computes sample weightings and texture coordinate offsets
            for one pass of a separable gaussian blur filter.
            </summary>
        </member>
        <member name="M:Engine.Rendering.Effects.BloomEffect.ComputeGaussian(System.Single)">
            <summary>
            Evaluates a single point on the gaussian falloff curve.
            Used for setting up the blur filter weightings.
            </summary>
        </member>
        <member name="T:Engine.Camera.Camera">
            <summary>
            A 2D camera with a list of effects, 
            allows easy tracking of objects and transitions between
            focus points.
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.isTransformDirty">
            <summary>
            True if information used to calc the transform matrix 
            has changed since it was last calculated
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.transformMatrix">
            <summary>
            Most recently calculated transform matrix- use isTransformDirty to see if value is still correct
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.mode">
            <summary>
            The current camera mode for this camera.  Can be locked, transition, etc.
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.viewport">
            <summary>
            The viewport that this camera maps world-space to
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.target">
            <summary>
            The current GameObject target.  Can be null when not in LockedTarget mode
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.oldTarget">
            <summary>
            The GameObject the camera was last locked to.  Used for smooth transitions
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.targetPos">
            <summary>
            The current Vector2 target.  Can be null when not in LockedPos mode
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.oldTargetPos">
            <summary>
            The Vector2 the camera was last locked to.  Used for smooth transitions
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.rotation">
            <summary>
            Camera rotation in radians.
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.scale">
            <summary>
            Camera scale- 1.0 is 100%, 2.0 is 200%, etc
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.transitionTime">
            <summary>
            Amount of time allowed to transition between two modes
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.transitionRemaining">
            <summary>
            Amount of time remaining in the transition
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.transitionPos">
            <summary>
            The position of the camera during a transition
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.lastFramePos">
            <summary>
            The position of the camera in world space in the last frame
            </summary>
        </member>
        <member name="F:Engine.Camera.Camera.effects">
            <summary>
            The camera effects currently applied to (or at least tracked by) this camera
            </summary>
        </member>
        <member name="M:Engine.Camera.Camera.#ctor(Microsoft.Xna.Framework.Graphics.Viewport)">
            <summary>
            Create a camera with a given viewport and scale 1.
            </summary>
            <param name="viewport">The viewport this camera maps to</param>
        </member>
        <member name="M:Engine.Camera.Camera.#ctor(Microsoft.Xna.Framework.Graphics.Viewport,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Create a camera with a given viewport and a given scale.
            </summary>
            <param name="viewport">The viewport this camera maps to</param>
            <param name="scale">Scaling factor (0.5 is 50% zoom, 2.0 is 200% zoom)</param>
        </member>
        <member name="M:Engine.Camera.Camera.#ctor(Engine.Camera.Camera)">
            <summary>
            Copy Constructor
            </summary>
            <param name="camera">The camera to copy</param>
        </member>
        <member name="M:Engine.Camera.Camera.Update(System.Single)">
            <summary>
            Update camera transitions and effects
            </summary>
            <param name="elapsedTime"></param>
        </member>
        <member name="M:Engine.Camera.Camera.UpdateTransition(System.Single)">
            <summary>
            Update any active transitions and move between lock states
            </summary>
        </member>
        <member name="M:Engine.Camera.Camera.UpdateEffects(System.Single)">
            <summary>
            Update camera effects, removing any that are inactive
            </summary>
        </member>
        <member name="M:Engine.Camera.Camera.AdvanceFrame">
            <summary>
            Advances the frame, so that position delta can be known within a timeframe.
            This method should be called as late as possible; end of draw is a good place.
            </summary>
        </member>
        <member name="M:Engine.Camera.Camera.LockPosition(Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            Lock the camera onto the specified position.
            </summary>
            <param name="pos">The position "lock on" to</param>
            <param name="immediate">If the lock is not immediate, the last transition position is saved and the transition finishes from transition position to the new position</param>
        </member>
        <member name="M:Engine.Camera.Camera.LockTarget(Engine.Entities.GameObject,System.Boolean)">
            <summary>
            Lock the camera onto the specified target.
            </summary>
            <param name="target">The GameplayObject to follow or "lock on" to</param>
            <param name="immediate">If the lock is not immediate, the last transition position is saved and the transition finishes from transition position to the new target</param>
        </member>
        <member name="M:Engine.Camera.Camera.TransitionTo(Engine.Entities.GameObject,System.Single,System.Boolean)">
            <summary>
            Very much like LockTarget(target, immediate) except it allows a specification of duration.
            </summary>
            <param name="target">The GameplayObject to follow or "lock on" to</param>
            <param name="duration">Amount of time for the transition from last target or pos, or transition position (depending on last mode)</param>
            <param name="immediate">If the lock is not immediate, the last transition position is saved and the transition finishes from transition position to the new target</param>
        </member>
        <member name="M:Engine.Camera.Camera.TransitionTo(Microsoft.Xna.Framework.Vector2,System.Single,System.Boolean)">
            <summary>
            Very much like LockPosition(pos, immediate) except it allows a specification of duration.
            </summary>
            <param name="pos">The position "lock on" to</param>
            <param name="duration">Amount of time for the transition from last target or pos, or transition position (depending on last mode)</param>
            <param name="immediate">If the lock is not immediate, the last transition position is saved and the transition finishes from transition position to the new position</param>
        </member>
        <member name="M:Engine.Camera.Camera.FinishTransition">
            <summary>
            Immediately finish any transition, and copy current target information
            to its equivalent 'old' field
            </summary>
        </member>
        <member name="M:Engine.Camera.Camera.AddEffect(Engine.Camera.Effects.CameraEffect)">
            <summary>
            Add an effect to this camera
            </summary>
            <param name="effect">The CameraEffect to add</param>
        </member>
        <member name="M:Engine.Camera.Camera.RemoveEffect(Engine.Camera.Effects.CameraEffect)">
            <summary>
            Remove an effect from this camera
            </summary>
            <param name="effect">The effect to remove</param>
        </member>
        <member name="M:Engine.Camera.Camera.EndEffect(Engine.Camera.Effects.CameraEffect)">
            <summary>
            Immediately end a camera effect, regardless of its remaining duration
            </summary>
            <param name="effect">The effect to end</param>
        </member>
        <member name="M:Engine.Camera.Camera.Screen2WorldCoords(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Converts a given 2D screen coordinate into World coordinates
            </summary>
            <param name="screenCoords">The point (in screen coordinates) to convert to world coordinates</param>
            <returns></returns>
        </member>
        <member name="M:Engine.Camera.Camera.CalculateTransformMatrix">
            <summary>
            Calculate the Transform Matrix for the current frame
            </summary>
        </member>
        <member name="M:Engine.Camera.Camera.CalculateEffectOffsets(System.Single@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Sum up the offsets from active effects
            </summary>
        </member>
        <member name="P:Engine.Camera.Camera.Rotation">
            <summary>
            Camera rotation in radians.
            </summary>
        </member>
        <member name="P:Engine.Camera.Camera.Scale">
            <summary>
            Camera scale- 1.0 is 100%, 2.0 is 200%, etc
            </summary>
        </member>
        <member name="P:Engine.Camera.Camera.LastFramePosition">
            <summary>
            The position of the camera in world space in the last frame
            </summary>
        </member>
        <member name="P:Engine.Camera.Camera.CurrentFramePosition">
            <summary>
            The position of the camera in world space in the current frame
            </summary>
        </member>
        <member name="P:Engine.Camera.Camera.DeltaFramePosition">
            <summary>
            The change in position of the camera between this frame and last frame
            </summary>
        </member>
        <member name="P:Engine.Camera.Camera.Dt">
            <summary>
            Returns the amount of time that elapsed in the last frame, as seen by the camera.
            </summary>
            <remarks>
            This is useful for effects that should be applied based on time and not frame cycle,
            Such as blur trails.
            </remarks>
        </member>
        <member name="P:Engine.Camera.Camera.TransformMatrix">
            <summary>
            Returns the transform matrix from world -> screen.
            When rendering, use this transform with:
            batch.Begin(SpriteSortMode, BlendState, SamplerState, DepthStencilState, RasterizerState, Effect, camera.TransformMatrix);
            </summary>
        </member>
        <member name="T:Engine.Utility.ColorTextureGenerator">
            <summary>
            Creates single color textures (i.e. for drawing rectangles).
            </summary>
        </member>
        <member name="M:Engine.Utility.ColorTextureGenerator.Create(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            Creates a 1x1 pixel black texture.
            </summary>
            <param name="graphicsDevice">The graphics device to use.</param>
            <returns>The newly created texture.</returns>
        </member>
        <member name="M:Engine.Utility.ColorTextureGenerator.Create(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Color)">
            <summary>
            Creates a 1x1 pixel texture of the specified color.
            </summary>
            <param name="graphicsDevice">The graphics device to use.</param>
            <param name="color">The color to set the texture to.</param>
            <returns>The newly created texture.</returns>
        </member>
        <member name="M:Engine.Utility.ColorTextureGenerator.Create(Microsoft.Xna.Framework.Graphics.GraphicsDevice,System.Int32,System.Int32,Microsoft.Xna.Framework.Color)">
            <summary>
            Creates a texture of the specified color.
            </summary>
            <param name="graphicsDevice">The graphics device to use.</param>
            <param name="width">The width of the texture.</param>
            <param name="height">The height of the texture.</param>
            <param name="color">The color to set the texture to.</param>
            <returns>The newly created texture.</returns>
        </member>
        <member name="T:Engine.Rendering.Effects.RepeaterEffect">
            <summary>
            Repeats a given RenderEffect n times in a row
            </summary>
        </member>
        <member name="F:Engine.Rendering.Effects.RepeaterEffect.Effect">
            <summary>
            The effect to repeat
            </summary>
        </member>
        <member name="F:Engine.Rendering.Effects.RepeaterEffect.Repetitions">
            <summary>
            The number of times the effect is repeated
            </summary>
        </member>
        <member name="M:Engine.Rendering.Effects.RepeaterEffect.#ctor">
            <summary>
            Repeats a noop effect 0 times
            </summary>
        </member>
        <member name="M:Engine.Rendering.Effects.RepeaterEffect.#ctor(Engine.Rendering.Pipeline.RenderEffect)">
            <summary>
            Repeats the given effect once
            </summary>
            <param name="effect"></param>
        </member>
        <member name="M:Engine.Rendering.Effects.RepeaterEffect.#ctor(Engine.Rendering.Pipeline.RenderEffect,System.Int32)">
            <summary>
            Repeats the given effect n times
            </summary>
            <param name="effect"></param>
            <param name="repetitions"></param>
        </member>
        <member name="M:Engine.Rendering.Effects.RepeaterEffect.LoadContent(Microsoft.Xna.Framework.Content.ContentManager,Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Load any required content the effect requires for rendering
            </summary>
            <param name="contentManager"></param>
            <param name="graphicsDevice"></param>
            <param name="spriteBatch"></param>
        </member>
        <member name="M:Engine.Rendering.Effects.RepeaterEffect.UnloadContent">
            <summary>
            Free up resources when you don't need to render bloom effects anymore.
            </summary>
        </member>
        <member name="M:Engine.Rendering.Effects.RepeaterEffect.ApplyEffect(Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Graphics.RenderTarget2D)">
            <summary>
            Renders the results of the effect on the preEffectTexture to the postEffectTexture.
            (preEffectTexture unmodified unless pre == post)
            </summary>
            <param name="preEffectTexture"></param>
            <param name="postEffectTexture"></param>
        </member>
        <member name="M:Engine.Rendering.Effects.RepeaterEffect.Reset">
            <summary>
            Reset any state the effect might track, such as camera deltas or elapsed game time
            </summary>
        </member>
        <member name="T:Engine.Input.Managers.InjectableInputManager">
            <summary>
              Can inject presses
            </summary>
        </member>
        <member name="F:Engine.Input.Managers.InjectableInputManager.InjectedPressedKeys">
            <summary>
              Programmatically injected binding presses
            </summary>
        </member>
        <member name="F:Engine.Input.Managers.InjectableInputManager.PressableKeys">
            <summary>
              Keys that the manager "contains"
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.#ctor">
            <summary>
              Constructor
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.#ctor(Engine.Input.Managers.InjectableInputManager)">
            <summary>
              Copy Constructor
            </summary>
            <param name="input"> </param>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.AddBinding(System.String,Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              See <see cref="M:Engine.Input.Managers.InputManager.AddBinding(System.String,Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)"/>
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.RemoveBinding(System.String,Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              See <see cref="M:Engine.Input.Managers.InputManager.RemoveBinding(System.String,Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)"/>
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.ContainsBinding(System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              See InputManager.ContainsBinding
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.ContainsBinding(Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              See InputManager.ContainsBinding
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.ClearBinding(System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              See <see cref="M:Engine.Input.Managers.InputManager.ClearBinding(System.String,Microsoft.Xna.Framework.PlayerIndex)"/>
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.ClearAllBindings">
            <summary>
              See <see cref="M:Engine.Input.Managers.InputManager.ClearAllBindings"/>
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.IsActive(System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)">
            <summary>
              See <see cref="M:Engine.Input.Managers.InputManager.IsActive(System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)"/>
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.GetCurrentBindings(System.String,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              See <see cref="M:Engine.Input.Managers.InputManager.GetCurrentBindings(System.String,Microsoft.Xna.Framework.PlayerIndex)"/>
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.BindingsUsing(Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              See <see cref="M:Engine.Input.Managers.InputManager.BindingsUsing(Engine.Input.InputBinding,Microsoft.Xna.Framework.PlayerIndex)"/>
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.Update">
            <summary>
              See <see cref="M:Engine.Input.Managers.InputManager.Update"/>
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.Press(System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)">
            <summary>
              "Press" a key in a given frame.
              Cannot press a binding unless it has been added to the InputManager
            </summary>
            <param name="bindingName"> The binding to press </param>
            <param name="player"> The player to press the binding for </param>
            <param name="state"> The frame to press it in </param>
        </member>
        <member name="M:Engine.Input.Managers.InjectableInputManager.Release(System.String,Microsoft.Xna.Framework.PlayerIndex,Engine.Input.FrameState)">
            <summary>
              "Release" a key in a given frame.
              Cannot release a binding unless it has been added to the InputManager
            </summary>
            <param name="bindingName"> The binding to release </param>
            <param name="player"> The player to release the binding for </param>
            <param name="state"> The frame to release it in </param>
        </member>
        <member name="P:Engine.Input.Managers.InjectableInputManager.GetModifiers">
            <summary>
              See <see cref="P:Engine.Input.Managers.InputManager.GetModifiers"/>
            </summary>
        </member>
        <member name="T:Engine.DataStructures.BidirectionalDict`2">
            <summary>
              Provides strict 1:1 mapping between two types.
              Not thread safe by any stretch of the imagination
            </summary>
            <typeparam name="T1"> </typeparam>
            <typeparam name="T2"> </typeparam>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.#ctor">
            <summary>
              Empty Bidirectional Dictionary
            </summary>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
              Construct the equivalent bi-directional dictionary from a single-direction dictionary
            </summary>
            <param name="dictionary"> </param>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.#ctor(System.Collections.Generic.IDictionary{`1,`0})">
            <summary>
              Construct the equivalent bi-directional dictionary from a T2 -> T1 dictionary
            </summary>
            <param name="dictionary"> </param>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.Add(`0,`1)">
            <summary>
              Add the specified pairing to the dictionary
            </summary>
            <param name="key"> </param>
            <param name="value"> </param>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.Add(`1,`0)">
            <summary>
              Add the specified pairing to the dictionary
            </summary>
            <param name="key"> </param>
            <param name="value"> </param>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.Remove(`0)">
            <summary>
              Remove the item and its corresponding value from the dictionary
            </summary>
            <param name="k"> </param>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.Remove(`1)">
            <summary>
              Remove the item and its corresponding value from the dictionary
            </summary>
            <param name="k"> </param>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.Contains(`0)">
            <summary>
              True if there is a pairing with the given value
            </summary>
            <param name="key"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.Contains(`1)">
            <summary>
              True if there is a pairing with the given value
            </summary>
            <param name="key"> </param>
            <returns> </returns>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.Clear">
            <summary>
              Clears all values
            </summary>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.GetValuesType1">
            <summary>
              Returns the values of the first type specification in the table
            </summary>
            <returns> </returns>
        </member>
        <member name="M:Engine.DataStructures.BidirectionalDict`2.GetValuesType2">
            <summary>
              Returns the values of the second type specification in the table
            </summary>
            <returns> </returns>
        </member>
        <member name="P:Engine.DataStructures.BidirectionalDict`2.Item(`1)">
            <summary>
              Gets or sets the values associated with the specified key
            </summary>
            <param name="key"> </param>
            <returns> </returns>
        </member>
        <member name="P:Engine.DataStructures.BidirectionalDict`2.Item(`0)">
            <summary>
              Gets or sets the values associated with the specified key
            </summary>
            <param name="key"> </param>
            <returns> </returns>
        </member>
        <member name="T:Engine.Input.DefaultBinding">
            <summary>
              See <see cref="T:Engine.Input.InputBinding"/>
            </summary>
        </member>
        <member name="M:Engine.Input.DefaultBinding.IsEqual(Engine.Input.InputBinding,System.Boolean)">
            <summary>
              Compares this Binding to another, and returns whether they are the same (with/without modifiers)
            </summary>
        </member>
        <member name="M:Engine.Input.DefaultBinding.IsActive(Engine.Input.InputSnapshot)">
            <summary>
              See <see cref="M:Engine.Input.InputBinding.IsActive(Engine.Input.InputSnapshot)"/>
            </summary>
        </member>
        <member name="M:Engine.Input.DefaultBinding.#ctor(Engine.Input.InputBinding[])">
            <summary>
              Initialize an InputBinding with an optional list of required modifiers
            </summary>
            <param name="modifiers"> Optional modifiers- Ctrl, Alt, Shift </param>
        </member>
        <member name="M:Engine.Input.DefaultBinding.#ctor(Engine.Input.DefaultBinding)">
            <summary>
              Copy Constructor
            </summary>
            <param name="other"> </param>
        </member>
        <member name="P:Engine.Input.DefaultBinding.Modifiers">
            <summary>
              Any modifiers required for this binding to be considered 'active'
            </summary>
        </member>
        <member name="T:Engine.Input.ThumbstickDirectionBinding">
            <summary>
              An InputBinding that checks if a certain ThumbstickDirection is active
              (beyond some threshold as defined in an InputManager's InputSettings)
            </summary>
        </member>
        <member name="M:Engine.Input.ThumbstickDirectionBinding.#ctor(Engine.Input.ThumbstickDirection,Engine.Input.Thumbstick,Engine.Input.InputBinding[])">
            <summary>
              An InputBinding wrapper for a ThumbstickDirection
            </summary>
            <param name="thumbstickDirection"> </param>
            <param name="thumbstick"> </param>
            <param name="modifiers"> </param>
        </member>
        <member name="M:Engine.Input.ThumbstickDirectionBinding.IsEqual(Engine.Input.InputBinding,System.Boolean)">
            <summary>
              Compares this Binding to another, and returns whether they are the same (with/without modifiers)
            </summary>
        </member>
        <member name="M:Engine.Input.ThumbstickDirectionBinding.IsActive(Engine.Input.InputSnapshot)">
            <summary>
              True if the  ThumbstickDirection of the specified Thumbstick is past the settings threshold
            </summary>
        </member>
        <member name="P:Engine.Input.ThumbstickDirectionBinding.Thumbstick">
            <summary>
              The Thumbstick (left or right) which is checked for activity past a threshold
            </summary>
        </member>
        <member name="P:Engine.Input.ThumbstickDirectionBinding.Direction">
            <summary>
              The Thumbstick Direction (up/down/left/right) which is checked for activity past a threshold
            </summary>
        </member>
        <member name="T:Engine.Input.MouseBinding">
            <summary>
              An InputBinding wrapper for a Thumbstick
            </summary>
        </member>
        <member name="M:Engine.Input.MouseBinding.#ctor(Engine.Input.MouseButton,Engine.Input.InputBinding[])">
            <summary>
              An InputBinding wrapper for a MouseButton
            </summary>
            <param name="mouseButton"> </param>
            <param name="modifiers"> </param>
        </member>
        <member name="M:Engine.Input.MouseBinding.IsEqual(Engine.Input.InputBinding,System.Boolean)">
            <summary>
              Compares this Binding to another, and returns whether they are the same (with/without modifiers)
            </summary>
        </member>
        <member name="M:Engine.Input.MouseBinding.IsActive(Engine.Input.InputSnapshot)">
            <summary>
              True if the Mouse button (without modifiers) is pressed
            </summary>
        </member>
        <member name="P:Engine.Input.MouseBinding.Button">
            <summary>
              The mouse button which is checked for activity
            </summary>
        </member>
        <member name="T:Engine.Input.ThumbstickBinding">
            <summary>
              An InputBinding that checks if a certain Thumbstick is active
              (beyond some threshold as defined in an InputManager's InputSettings)
              (direction doesn't matter)
            </summary>
        </member>
        <member name="M:Engine.Input.ThumbstickBinding.#ctor(Engine.Input.Thumbstick,Engine.Input.InputBinding[])">
            <summary>
              An InputBinding wrapper for a Thumbstick
            </summary>
            <param name="thumbstick"> </param>
            <param name="modifiers"> </param>
        </member>
        <member name="M:Engine.Input.ThumbstickBinding.IsEqual(Engine.Input.InputBinding,System.Boolean)">
            <summary>
              Compares this Binding to another, and returns whether they are the same (with/without modifiers)
            </summary>
        </member>
        <member name="M:Engine.Input.ThumbstickBinding.IsActive(Engine.Input.InputSnapshot)">
            <summary>
              True if the thumbstick (without modifiers) is past the settings threshold
            </summary>
        </member>
        <member name="P:Engine.Input.ThumbstickBinding.Thumbstick">
            <summary>
              The Thumbstick (left or right) which is checked for activity past a threshold
            </summary>
        </member>
        <member name="T:Engine.Input.ButtonBinding">
            <summary>
              An InputBinding wrapper for a Button
            </summary>
        </member>
        <member name="M:Engine.Input.ButtonBinding.#ctor(Microsoft.Xna.Framework.Input.Buttons,Engine.Input.InputBinding[])">
            <summary>
              An InputBinding wrapper for a Button
            </summary>
            <param name="button"> </param>
            <param name="modifiers"> </param>
        </member>
        <member name="M:Engine.Input.ButtonBinding.IsEqual(Engine.Input.InputBinding,System.Boolean)">
            <summary>
              Compares this Binding to another, and returns whether they are the same (with/without modifiers)
            </summary>
        </member>
        <member name="M:Engine.Input.ButtonBinding.IsActive(Engine.Input.InputSnapshot)">
            <summary>
              True if the Button (without modifiers) is pressed
            </summary>
        </member>
        <member name="P:Engine.Input.ButtonBinding.Button">
            <summary>
              The Button which is checked for activity
            </summary>
        </member>
        <member name="T:Engine.Input.KeyBinding">
            <summary>
              An InputBinding wrapper for a keyboard Key
            </summary>
        </member>
        <member name="M:Engine.Input.KeyBinding.#ctor(Microsoft.Xna.Framework.Input.Keys,Engine.Input.InputBinding[])">
            <summary>
              InputBinding wrapper for a keyboard Key
            </summary>
            <param name="key"> </param>
            <param name="modifiers"> </param>
        </member>
        <member name="M:Engine.Input.KeyBinding.IsEqual(Engine.Input.InputBinding,System.Boolean)">
            <summary>
              Compares this Binding to another, and returns whether they are the same (with/without modifiers)
            </summary>
        </member>
        <member name="M:Engine.Input.KeyBinding.IsActive(Engine.Input.InputSnapshot)">
            <summary>
              True if the key (without modifiers) is pressed
            </summary>
        </member>
        <member name="P:Engine.Input.KeyBinding.Key">
            <summary>
              The Key which is checked for activity
            </summary>
        </member>
        <member name="T:Engine.Input.ModifierKey">
            <summary>
              Custom KeyBinding for double-keyed modifiers
            </summary>
        </member>
        <member name="P:Engine.Input.ModifierKey.Ctrl">
            <summary>
              Control key
            </summary>
        </member>
        <member name="P:Engine.Input.ModifierKey.Alt">
            <summary>
              Alt key
            </summary>
        </member>
        <member name="P:Engine.Input.ModifierKey.Shift">
            <summary>
              Shift key
            </summary>
        </member>
        <member name="T:Engine.Input.TriggerBinding">
            <summary>
              An InputBinding that checks if a certain Trigger is active
              (beyond some threshold as defined in an InputManager's InputSettings)
            </summary>
        </member>
        <member name="M:Engine.Input.TriggerBinding.#ctor(Engine.Input.Trigger,Engine.Input.InputBinding[])">
            <summary>
              InputBinding wrapper for GamePad triggers
            </summary>
            <param name="trigger"> </param>
            <param name="modifiers"> </param>
        </member>
        <member name="M:Engine.Input.TriggerBinding.IsEqual(Engine.Input.InputBinding,System.Boolean)">
            <summary>
              Compares this Binding to another, and returns whether they are the same (with/without modifiers)
            </summary>
        </member>
        <member name="M:Engine.Input.TriggerBinding.IsActive(Engine.Input.InputSnapshot)">
            <summary>
              True if the trigger (without modifiers) is past the settings threshold
            </summary>
        </member>
        <member name="P:Engine.Input.TriggerBinding.Trigger">
            <summary>
              The left or right trigger
            </summary>
        </member>
        <member name="T:Engine.Networking.BasicServer">
            <summary>
            A basic implementation of the <see cref="T:Engine.Networking.IServer"/> interface
            </summary>
        </member>
        <member name="F:Engine.Networking.BasicServer.clientTable">
            <summary>
            Two-way mapping between A client's TcpClient and their GUID
            </summary>
        </member>
        <member name="F:Engine.Networking.BasicServer.clientThreads">
            <summary>
            Mapping from clients to their read threads
            </summary>
        </member>
        <member name="F:Engine.Networking.BasicServer.authTable">
            <summary>
            True if a client have authenticated with the server
            </summary>
        </member>
        <member name="F:Engine.Networking.BasicServer.log">
            <summary>
            The server log
            </summary>
        </member>
        <member name="M:Engine.Networking.BasicServer.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            Construct a basic server such that it is ready to be started.
            </summary>
            <param name="localaddr"></param>
            <param name="port"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.#ctor(System.Net.IPAddress,System.Int32,System.String)">
            <summary>
            Construct a basic server such that it is ready to be started, and possibly using the default connect
            behavior.
            </summary>
            <param name="localaddr"></param>
            <param name="port"></param>
            <param name="logFileName"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.Start">
            <summary>
            See <see cref="M:Engine.Networking.IServer.Start"/>
            </summary>
        </member>
        <member name="M:Engine.Networking.BasicServer.PollForClients">
            <summary>
            Checks listener forever and adds new clients as they try to connect
            </summary>
        </member>
        <member name="M:Engine.Networking.BasicServer.Stop">
            <summary>
            See <see cref="M:Engine.Networking.IServer.Stop"/>
            </summary>
        </member>
        <member name="M:Engine.Networking.BasicServer.Shutdown(System.Boolean)">
            <summary>
            See <see cref="M:Engine.Networking.IServer.Shutdown(System.Boolean)"/>
            </summary>
            <param name="immediate"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.Connect(Engine.Networking.Client,Engine.Networking.ServerEventArgs)">
            <summary>
            See <see cref="M:Engine.Networking.IServer.Connect(Engine.Networking.Client,Engine.Networking.ServerEventArgs)"/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.DefaultHandle_OnConnect(System.Object,Engine.Networking.ServerEventArgs)">
            <summary>
            Default handler for the OnConnect event.
            Registers the client in the clientTable, registers a new thread in the clientThread table,
            and starts that thread.  The thread calls DefaultClientThreadFunction
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.DefaultClientThreadFunction(System.Object)">
            <summary>
            Constantly checks a client for incoming messages
            </summary>
            <param name="oClient"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.OnClientReadException(System.String,Engine.Networking.Client)">
            <summary>
            Called when we try to read from a client stream and fail.
            </summary>
            <param name="reason"></param>
            <param name="client"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.Disconnect(Engine.Networking.Client,Engine.Networking.ServerEventArgs)">
            <summary>
            See <see cref="M:Engine.Networking.IServer.Disconnect(Engine.Networking.Client,Engine.Networking.ServerEventArgs)"/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.Authenticate(Engine.Networking.Client,Engine.Networking.ServerEventArgs)">
            <summary>
            See <see cref="M:Engine.Networking.IServer.Authenticate(Engine.Networking.Client,Engine.Networking.ServerEventArgs)"/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.ReceivePacket(Engine.Networking.Packets.Packet,Engine.Networking.Client)">
            <summary>
            See <see cref="M:Engine.Networking.IServer.ReceivePacket(Engine.Networking.Packets.Packet,Engine.Networking.Client)"/>
            </summary>
            <param name="packet"></param>
            <param name="client"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.SendPacket(Engine.Networking.Packets.Packet,Engine.Networking.Client[])">
            <summary>
            See <see cref="M:Engine.Networking.IServer.SendPacket(Engine.Networking.Packets.Packet,Engine.Networking.Client[])"/>
            </summary>
            <param name="packet"></param>
            <param name="clients"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.WritePacket(Engine.Networking.Packets.Packet,Engine.Networking.Client)">
            <summary>
            Tries to write a packet to a client
            </summary>
            <param name="packet"></param>
            <param name="client"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.OnSendPacketException(Engine.Networking.Packets.Packet,System.String,Engine.Networking.Client)">
            <summary>
            Called when we try to send a message to a client but that send fails.
            </summary>
            <param name="packet"></param>
            <param name="reason"></param>
            <param name="client"></param>
        </member>
        <member name="M:Engine.Networking.BasicServer.IsAuthenticated(Engine.Networking.Client)">
            <summary>
            See <see cref="M:Engine.Networking.IServer.IsAuthenticated(Engine.Networking.Client)"/>
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Networking.BasicServer.GetClientString(Engine.Networking.Client)">
            <summary>
            See <see cref="M:Engine.Networking.IServer.GetClientString(Engine.Networking.Client)"/>
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Networking.BasicServer.GetClient(System.String)">
            <summary>
            See <see cref="M:Engine.Networking.IServer.GetClient(System.String)"/>
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Networking.BasicServer.GetClientStrings(Engine.Networking.Client[])">
            <summary>
            See <see cref="M:Engine.Networking.IServer.GetClientStrings(Engine.Networking.Client[])"/>
            </summary>
            <param name="clients"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Networking.BasicServer.GetClients(System.String[])">
            <summary>
            See <see cref="M:Engine.Networking.IServer.GetClients(System.String[])"/>
            </summary>
            <param name="clients"></param>
            <returns></returns>
        </member>
        <member name="P:Engine.Networking.BasicServer.IsRunning">
            <summary>
            See <see cref="P:Engine.Networking.IServer.IsRunning"/>
            </summary>
        </member>
        <member name="E:Engine.Networking.BasicServer.OnStart">
            <summary>
            See <see cref="E:Engine.Networking.IServer.OnStart"/>
            </summary>
        </member>
        <member name="E:Engine.Networking.BasicServer.OnStop">
            <summary>
            See <see cref="E:Engine.Networking.IServer.OnStop"/>
            </summary>
        </member>
        <member name="E:Engine.Networking.BasicServer.OnShutdown">
            <summary>
            See <see cref="E:Engine.Networking.IServer.OnShutdown"/>
            </summary>
        </member>
        <member name="E:Engine.Networking.BasicServer.OnConnect">
            <summary>
            See <see cref="E:Engine.Networking.IServer.OnConnect"/>
            </summary>
        </member>
        <member name="E:Engine.Networking.BasicServer.OnDisconnect">
            <summary>
            See <see cref="E:Engine.Networking.IServer.OnDisconnect"/>
            </summary>
        </member>
        <member name="E:Engine.Networking.BasicServer.OnAuthenticate">
            <summary>
            See <see cref="E:Engine.Networking.IServer.OnAuthenticate"/>
            </summary>
        </member>
        <member name="T:Engine.Input.InputSnapshot">
            <summary>
              A snapshot of the polled input devices so that method signatures don't get too cluttered
            </summary>
        </member>
        <member name="F:Engine.Input.InputSnapshot.GamePadState">
            <summary>
              The GamePadState at the time of snapshotting
            </summary>
        </member>
        <member name="F:Engine.Input.InputSnapshot.InputSettings">
            <summary>
              The InputSettings at the time of snapshotting
            </summary>
        </member>
        <member name="F:Engine.Input.InputSnapshot.KeyboardState">
            <summary>
              The KeyboardState at the time of snapshotting
            </summary>
        </member>
        <member name="F:Engine.Input.InputSnapshot.MouseState">
            <summary>
              The MouseState at the time of snapshotting
            </summary>
        </member>
        <member name="M:Engine.Input.InputSnapshot.#ctor(System.Nullable{Microsoft.Xna.Framework.Input.KeyboardState},System.Nullable{Microsoft.Xna.Framework.Input.GamePadState},System.Nullable{Microsoft.Xna.Framework.Input.MouseState},Engine.Input.InputSettings)">
            <summary>
              Snapshot a set of input device states
            </summary>
        </member>
        <member name="M:Engine.Input.InputSnapshot.Merge(Engine.Input.InputSnapshot)">
            <summary>
              Creates a new snapshot where non-null values of the other snapshot overwrite the values from this snapshot.
            </summary>
        </member>
        <member name="M:Engine.Input.InputSnapshot.Merge(Engine.Input.InputSnapshot,Engine.Input.InputSnapshot)">
            <summary>
              Merge the values of two snapshots into a new snapshot, where non-null values from the second overwrite those of the first.
            </summary>
        </member>
        <member name="M:Engine.Input.InputSnapshot.With(Microsoft.Xna.Framework.Input.KeyboardState)">
            <summary>
              Snapshot a set of input device states
            </summary>
        </member>
        <member name="M:Engine.Input.InputSnapshot.With(Microsoft.Xna.Framework.Input.GamePadState)">
            <summary>
              Snapshot a set of input device states
            </summary>
        </member>
        <member name="M:Engine.Input.InputSnapshot.With(Microsoft.Xna.Framework.Input.MouseState)">
            <summary>
              Snapshot a set of input device states
            </summary>
        </member>
        <member name="M:Engine.Input.InputSnapshot.With(Engine.Input.InputSettings)">
            <summary>
              Snapshot a set of input device states
            </summary>
        </member>
        <member name="T:Engine.Events.EventWatchers.EventWatchTiming">
            <summary>
            Describes at which point in an event's lifetime a watcher would want to be notified
            of the event.
            </summary>
        </member>
        <member name="F:Engine.Events.EventWatchers.EventWatchTiming.None">
            <summary>
            The watcher doesn't want to know about events
            </summary>
        </member>
        <member name="F:Engine.Events.EventWatchers.EventWatchTiming.OnCreate">
            <summary>
            When the event is created
            </summary>
        </member>
        <member name="F:Engine.Events.EventWatchers.EventWatchTiming.OnFire">
            <summary>
            When the event is fired by an event manager
            </summary>
        </member>
        <member name="F:Engine.Events.EventWatchers.EventWatchTiming.Any">
            <summary>
            The watcher wants to be notified at any time.
            (This will either notifiy at every stage, or the first, depending on implementation
            </summary>
        </member>
        <member name="T:Engine.Camera.Effects.DampedOscillationEffect">
            <summary>
            This effect doesn't impact the camera in any way
            However, it keeps the CameraEffect cleaner (not all effects need freq, decay, mag)
            and prevents repitition of variables in subclasses (Shake, Bounce)
            </summary>
        </member>
        <member name="F:Engine.Camera.Effects.DampedOscillationEffect.decay">
            <summary>
            Decay coeffecient in expoenential decay function of magnitude
            </summary>
        </member>
        <member name="F:Engine.Camera.Effects.DampedOscillationEffect.mag">
            <summary>
            Magnitude
            </summary>
        </member>
        <member name="F:Engine.Camera.Effects.DampedOscillationEffect.freq">
            <summary>
            Oscillation frequency
            </summary>
        </member>
        <member name="F:Engine.Camera.Effects.DampedOscillationEffect.magFunction">
            <summary>
            A function that modifies the magnitude of the bounce over time
            </summary>
        </member>
        <member name="F:Engine.Camera.Effects.DampedOscillationEffect.oscillateFunction">
            <summary>
            A function that describes the oscillation of the bounce over time
            </summary>
        </member>
        <member name="M:Engine.Camera.Effects.DampedOscillationEffect.#ctor(Engine.Camera.Camera,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            An effect which oscillates between [-mag, +mag] and whose mag decays over time
            </summary>
            <param name="camera"></param>
            <param name="dur"></param>
            <param name="decay"></param>
            <param name="mag"></param>
            <param name="freq"></param>
        </member>
        <member name="T:Engine.Camera.Effects.CameraShakeEffect">
            <summary>
            Creates a radial shake effect, using damped oscillation
            One pass goes from 0 -> mag -> 0 -> -mag -> 0
            Specify the number of passes to make via frequency
            </summary>
        </member>
        <member name="M:Engine.Camera.Effects.CameraShakeEffect.#ctor(Engine.Camera.Camera,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Applys a rotation effect that oscillates from -mag to +mag and decays over time.
            </summary>
            <param name="camera">The camera the effect is applied to</param>
            <param name="dur">Duration in ms for the effect to occur over</param>
            <param name="decay">Decay coeffecient of the shaking.  Use 0 for no decay</param>
            <param name="mag">Maximum magnitude in radians for the camera to rotate</param>
            <param name="freq">Number of times the camera makes a full left -> right -> left pass</param>
        </member>
        <member name="M:Engine.Camera.Effects.CameraShakeEffect.rotation">
            <summary>
            Camera's rotation offset
            </summary>
            <returns></returns>
        </member>
        <member name="T:Engine.Camera.Effects.CameraBounceEffect">
            <summary>
            Creates a 'pop' or bounce effect, using damped oscillation
            One pass goes from 0 -> cameraScale * mag -> 0 -> -cameraScale * mag -> 0
            Specify the number of passes to make via frequency
            </summary>
        </member>
        <member name="M:Engine.Camera.Effects.CameraBounceEffect.#ctor(Engine.Camera.Camera,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Applys a scale effect that oscillates from (1 - mag) to (1 + mag) and decays over time.
            </summary>
            <param name="camera">The camera the effect is applied to</param>
            <param name="dur">Duration in ms for the effect to occur over</param>
            <param name="decay">Decay coeffecient of the zoom.  Use 0 for no decay</param>
            <param name="mag">Maximum magnitude in percent original zoom to move by</param>
            <param name="freq">Number of times the camera makes a full in -> out -> in pass</param>
        </member>
        <member name="M:Engine.Camera.Effects.CameraBounceEffect.scaleX">
            <summary>
            Camera's horizontal scale offset
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.Camera.Effects.CameraBounceEffect.scaleY">
            <summary>
            Camera's vertical scale offset
            </summary>
            <returns></returns>
        </member>
        <member name="T:Engine.DataStructures.DictionaryExtensions">
            <summary>
            Extensions that make certain lookup operations easier
            </summary>
        </member>
        <member name="M:Engine.DataStructures.DictionaryExtensions.GetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Tries to get a value from the dictionary.  If the dictionary
            returns a null value for the value, returns a default value
            </summary>
        </member>
        <member name="M:Engine.DataStructures.DictionaryExtensions.GetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>
            Tries to get a value from the dictionary.  If the dictionary
            returns a null value for the value, returns the value from
            a function which provides TValue objects
            </summary>
        </member>
        <member name="T:Engine.Tiles.TileManager`1">
            <summary>
            Tracks buffered chunks and point/chunk updating
            </summary>
        </member>
        <member name="M:Engine.Tiles.TileManager`1.#ctor(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Create a TileManager which tracks n chunks, where n is the product of the buffer dimensions.
            Each chunk has m tiles, where m is the product of the chunk dimensions
            </summary>
            <param name="bufferDimensions"></param>
            <param name="chunkDimensions"></param>
        </member>
        <member name="M:Engine.Tiles.TileManager`1.GetChunk(Microsoft.Xna.Framework.Point)">
            <summary>
            Gets the chunk which contains the given global tile position
            </summary>
            <param name="globalTilePosition">The global position of a tile which is in the desired chunk</param>
            <returns>null if there is no such chunk</returns>
        </member>
        <member name="M:Engine.Tiles.TileManager`1.UpdateTile(Microsoft.Xna.Framework.Point,`0)">
            <summary>
            Update a single tile in a specific chunk
            </summary>
            <param name="globalTilePosition">The global coordinates of the tile</param>
            <param name="value">The value to give the specified tile</param>
        </member>
        <member name="M:Engine.Tiles.TileManager`1.CacheChunk(Microsoft.Xna.Framework.Point,`0[],System.Int32)">
            <summary>
            Loads a chunk 
            </summary>
            <param name="globalChunkPosition"></param>
            <param name="data"></param>
            <param name="startIndex"></param>
        </member>
        <member name="P:Engine.Tiles.TileManager`1.Chunks">
            <summary>
            Chunks of tiles loaded in memory
            </summary>
        </member>
        <member name="P:Engine.Tiles.TileManager`1.BufferDimensions">
            <summary>
            The dimensions of chunks buffered.
            </summary>
            <example>
            For BufferDimensions (3,3)
            we would buffer the following:
            .....
            .+++.
            .+++.
            .+++.
            .....
            where   "." is unbuffered,
                    "+" is buffered
            </example>
        </member>
        <member name="P:Engine.Tiles.TileManager`1.ChunkDimensions">
            <summary>
            The size of a single chunk
            </summary>
        </member>
        <member name="T:Engine.Networking.ServerEventArgs">
            <summary>
            Events passed when an authentication attempt occurs.
            </summary>
        </member>
        <member name="M:Engine.Networking.ServerEventArgs.#ctor(System.Boolean,Engine.Networking.Client)">
            <summary>
            Initialize a set of parameterless server interaction args at the current time
            </summary>
            <param name="success"></param>
            <param name="client"></param>
        </member>
        <member name="M:Engine.Networking.ServerEventArgs.#ctor(System.Boolean,Engine.Networking.Client,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Initialize a set of server interaction args at the current time with the given parameters
            </summary>
            <param name="success"></param>
            <param name="client"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Engine.Networking.ServerEventArgs.#ctor(System.Boolean,Engine.Networking.Client,System.Collections.Generic.IDictionary{System.String,System.String},System.DateTime)">
            <summary>
            Initialize a set of server interaction args at the given time with the given parameters
            </summary>
            <param name="success"></param>
            <param name="client"></param>
            <param name="parameters"></param>
            <param name="time"></param>
        </member>
        <member name="P:Engine.Networking.ServerEventArgs.Success">
            <summary>
            Was the interaction successful
            </summary>
        </member>
        <member name="P:Engine.Networking.ServerEventArgs.Client">
            <summary>
            The TcpClient that interacted
            </summary>
        </member>
        <member name="P:Engine.Networking.ServerEventArgs.Time">
            <summary>
            When the interaction occured
            </summary>
        </member>
        <member name="P:Engine.Networking.ServerEventArgs.Parameters">
            <summary>
            Keyed values that the client provided to the server during the interaction
            </summary>
        </member>
        <member name="T:Engine.Input.EventInput.KeyboardLayout">
            <summary>
            Hooks up windows dlls for keyboard event capture
            </summary>
        </member>
        <member name="M:Engine.Input.EventInput.KeyboardLayout.getName">
            <summary>
            The name of the keyboard layout
            </summary>
            <returns></returns>
        </member>
        <member name="T:Engine.Input.EventInput.CharacterEventArgs">
            <summary>
            EventArgs of a character press
            (includes info about modifers such as alt, as well as repeat count)
            </summary>
        </member>
        <member name="M:Engine.Input.EventInput.CharacterEventArgs.#ctor(System.Char,System.Int32)">
            <summary>
            Construct a new character event arg for a key press
            </summary>
            <param name="character"></param>
            <param name="lParam"></param>
        </member>
        <member name="P:Engine.Input.EventInput.CharacterEventArgs.Character">
            <summary>
            The character that was entered
            </summary>
        </member>
        <member name="P:Engine.Input.EventInput.CharacterEventArgs.Param">
            <summary>
            Extra info such as modifers that were pressed
            </summary>
        </member>
        <member name="P:Engine.Input.EventInput.CharacterEventArgs.RepeatCount">
            <summary>
            How many times the key was registered
            </summary>
        </member>
        <member name="P:Engine.Input.EventInput.CharacterEventArgs.ExtendedKey">
            <summary>
            True if this was an extended key
            </summary>
        </member>
        <member name="P:Engine.Input.EventInput.CharacterEventArgs.AltPressed">
            <summary>
            Was alt depressed when the key was entered
            </summary>
        </member>
        <member name="P:Engine.Input.EventInput.CharacterEventArgs.PreviousState">
            <summary>
            The state the key was in before this event
            </summary>
        </member>
        <member name="P:Engine.Input.EventInput.CharacterEventArgs.TransitionState">
            <summary>
            Is this a transition from a different previous state
            </summary>
        </member>
        <member name="T:Engine.Input.EventInput.KeyEventArgs">
            <summary>
            EventArgs of a Keys press
            </summary>
        </member>
        <member name="M:Engine.Input.EventInput.KeyEventArgs.#ctor(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Construct a new Key event arg for a key press
            </summary>
            <param name="keyCode"></param>
        </member>
        <member name="P:Engine.Input.EventInput.KeyEventArgs.KeyCode">
            <summary>
            The key that was pressed
            </summary>
        </member>
        <member name="T:Engine.Input.EventInput.CharEnteredHandler">
            <summary>
            EventHandler for char events
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Engine.Input.EventInput.KeyEventHandler">
            <summary>
            EventHandler for Key events
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Engine.Input.EventInput.EventInput">
            <summary>
            Converts win dll hooked input events into nice CharacterEvents and KeyEvents
            </summary>
        </member>
        <member name="M:Engine.Input.EventInput.EventInput.Initialize(Microsoft.Xna.Framework.GameWindow)">
            <summary>
            Initialize the TextInput with the given GameWindow.
            </summary>
            <param name="window">The XNA window to which text input should be linked.</param>
        </member>
        <member name="E:Engine.Input.EventInput.EventInput.CharEntered">
            <summary>
            Event raised when a character has been entered.
            </summary>
        </member>
        <member name="E:Engine.Input.EventInput.EventInput.KeyDown">
            <summary>
            Event raised when a key has been pressed down. May fire multiple times due to keyboard repeat.
            </summary>
        </member>
        <member name="E:Engine.Input.EventInput.EventInput.KeyUp">
            <summary>
            Event raised when a key has been released.
            </summary>
        </member>
        <member name="T:Engine.Input.EventInput.KeyboardDispatcher">
            <summary>
            Sends out read calls when input is handled from EventInput
            </summary>
        </member>
        <member name="M:Engine.Input.EventInput.KeyboardDispatcher.Initialize(Microsoft.Xna.Framework.GameWindow)">
            <summary>
            Initialize the KeyboardDispatcher by connecting it to a GameWindow
            </summary>
            <param name="window"></param>
        </member>
        <member name="M:Engine.Input.EventInput.KeyboardDispatcher.RegisterListener(Engine.Input.EventInput.IKeyboardSubscriber)">
            <summary>
            Add a listener that receives messages when new keys are pressed
            </summary>
            <param name="subscriber"></param>
        </member>
        <member name="M:Engine.Input.EventInput.KeyboardDispatcher.UnregisterListener(Engine.Input.EventInput.IKeyboardSubscriber)">
            <summary>
            Remove a listener
            </summary>
            <param name="subscriber"></param>
        </member>
        <member name="T:Engine.Utility.EnumUtil">
            <summary>
            Provides iteration over the values of an enumeration
            </summary>
        </member>
        <member name="M:Engine.Utility.EnumUtil.GetValues``1">
            <summary>
            An iterator over the values of an enumeration
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Engine.Utility.CollectionExtensions">
            <summary>
            Extensions for commonly used collection patterns
            </summary>
        </member>
        <member name="M:Engine.Utility.CollectionExtensions.PrettyPrint``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Takes an enumerable and returns the string such that each element is printed,
            separated by the given separator.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Utility.CollectionExtensions.PopRandomElement``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Selects a random element from the collection, removes and returns it
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="T:Engine.Input.Managers.OptimizedKeyboardManager">
            <summary>
              Only supports keyboard input, only supports one binding per name.
              So the binding "jump" cannot be assigned to both Keys.Up and Keys.Space
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.OptimizedKeyboardManager.#ctor">
            <summary>
              Constructor
            </summary>
        </member>
        <member name="M:Engine.Input.Managers.OptimizedKeyboardManager.CoerceRawInputBinding(Engine.Input.InputBinding,System.Boolean)">
            <summary>
              Ensures only Ctrl/Alt/Shift modifiers are listed, returns null for non-Key InputBindings
            </summary>
        </member>
        <member name="T:Engine.Entities.Components.PhysicsComponent">
            <summary>
            Handles all physics interactions of a GameObject
            - or a piece or collection of (a) GameObject(s).
            </summary>
        </member>
        <member name="M:Engine.Entities.Components.PhysicsComponent.#ctor">
            <summary>
            Create a default Phyics Component
            </summary>
        </member>
        <member name="M:Engine.Entities.Components.PhysicsComponent.#ctor(Engine.Entities.Components.PhysicsComponent)">
            <summary>
            Copy constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="P:Engine.Entities.Components.PhysicsComponent.Dimensions">
            <summary>
            Dimensions of the AABB of the component
            </summary>
        </member>
        <member name="P:Engine.Entities.Components.PhysicsComponent.Position">
            <summary>
            Position of the component (depending on implementation,
            can be center or corner of component)
            </summary>
        </member>
        <member name="P:Engine.Entities.Components.PhysicsComponent.Velocity">
            <summary>
            Velocity of the component
            </summary>
        </member>
        <member name="P:Engine.Entities.Components.PhysicsComponent.Acceleration">
            <summary>
            Acceleration of the component
            </summary>
        </member>
        <member name="P:Engine.Entities.Components.PhysicsComponent.DecayAcceleration">
            <summary>
            Percent of acceleration that decays per second
            </summary>
        </member>
        <member name="P:Engine.Entities.Components.PhysicsComponent.Mass">
            <summary>
            Mass of the component
            (objects are usually treated as point masses)
            </summary>
        </member>
        <member name="P:Engine.Entities.Components.PhysicsComponent.MaxSpeed">
            <summary>
            Maximum magnitude of the component
            </summary>
        </member>
        <member name="P:Engine.Entities.Components.PhysicsComponent.Rotation">
            <summary>
            Rotation (counter-clockwise from +x) of the component
            </summary>
        </member>
        <member name="T:Engine.Rendering.Effects.BlurEffect">
            <summary>
            Blurs the movement of objects, appropriately compensating for screen shake (radial) and position changes.
            Does not account for scale changes, which will 
            </summary>
        </member>
        <member name="F:Engine.Rendering.Effects.BlurEffect.AlphaDecay">
            <summary>
            The percent of the previous frames that decays each frame.
            The amount of opacity from previous frames that remains is 1 - AlphaDecay.
            <example>
            For AlphaDecay = 0.05, 95% of the previous frame is kept.  It will take 14 frames to get to &lt;= 50% opacity
            </example>
            </summary>
        </member>
        <member name="M:Engine.Rendering.Effects.BlurEffect.#ctor">
            <summary>
            Default BlurEffect - never decays
            </summary>
        </member>
        <member name="M:Engine.Rendering.Effects.BlurEffect.#ctor(System.Single)">
            <summary>
            BlurEffect which loses alphaDecay% opacity per frame
            </summary>
            <param name="alphaDecay"></param>
        </member>
        <member name="M:Engine.Rendering.Effects.BlurEffect.LoadContent(Microsoft.Xna.Framework.Content.ContentManager,Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Load any required content the effect requires for rendering
            </summary>
            <param name="contentManager"></param>
            <param name="graphicsDevice"></param>
            <param name="spriteBatch"></param>
        </member>
        <member name="M:Engine.Rendering.Effects.BlurEffect.UnloadContent">
            <summary>
            Free up resources when you don't need to render bloom effects anymore.
            </summary>
        </member>
        <member name="M:Engine.Rendering.Effects.BlurEffect.SetFrameDelta(Microsoft.Xna.Framework.Vector2)">
            <summary>
            This should most likely be called every frame, to update the change in position of the camera.
            This will make the blur render w.r.t. the player.  Of course, you could also blur by a normal to
            the camera delta or an oscillating angle to the player, to create different effects.
            </summary>
            <param name="delta">Change in position of the blur effect since the last frame.  
                                Do not scale the offset to texture coordinates, that will be done for you.</param>
        </member>
        <member name="M:Engine.Rendering.Effects.BlurEffect.ApplyEffect(Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Graphics.RenderTarget2D)">
            <summary>
            Renders the results of the effect on the preEffectTexture to the postEffectTexture.
            (preEffectTexture unmodified unless pre == post)
            </summary>
            <param name="preEffectTexture"></param>
            <param name="postEffectTexture"></param>
        </member>
        <member name="M:Engine.Rendering.Effects.BlurEffect.Reset">
            <summary>
            Reset any state the effect might track, such as camera deltas or elapsed game time
            </summary>
        </member>
        <member name="T:Engine.Rendering.BasicShapeRenderer">
            <summary>
            Useful for rendering very basic shapes with solid colors,
            such as squares, rectangles, and outlines of said shapes
            </summary>
        </member>
        <member name="M:Engine.Rendering.BasicShapeRenderer.Initialize(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            The BasicShapeRenderer won't actually render until it's been initialized
            </summary>
            <param name="graphicsDevice"></param>
        </member>
        <member name="M:Engine.Rendering.BasicShapeRenderer.DrawSolidSquare(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,System.Single)">
            <summary>
            Draws a filled square whose center is position
            </summary>
            <param name="batch">SpriteBatch for drawing</param>
            <param name="position">Center of the Square</param>
            <param name="color">Color of the square</param>
            <param name="width">Square side length</param>
            <param name="rotation">Rotation in radians about the center</param>
        </member>
        <member name="M:Engine.Rendering.BasicShapeRenderer.DrawSquareOutline(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,System.Single,System.Single)">
            <summary>
            Draws a hollow square whose center is position, of width lineWidth (default 1px, does not exceed width)
            </summary>
            <param name="batch">SpriteBatch for drawing</param>
            <param name="position">Center of the Square</param>
            <param name="color">Color of the square</param>
            <param name="width">Square side length</param>
            <param name="rotation">Rotation in radians about the center</param>
            <param name="lineWidth">Width in pixels of the line</param>
        </member>
        <member name="M:Engine.Rendering.BasicShapeRenderer.DrawRectangleOutline(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>
            Draws a hollow rectangle whose center is position, of width lineWidth (default 1px, does not exceed width)
            </summary>
            <param name="batch">SpriteBatch for drawing</param>
            <param name="position">Center of the rectangle</param>
            <param name="color">Color of the rectangle</param>
            <param name="dimensions">Dimensions of the rectangle</param>
            <param name="rotation">Rotation in radians about the center</param>
            <param name="lineWidth">Width in pixels of the line</param>
        </member>
        <member name="T:Engine.Logging.Log">
            <summary>
              See <see cref="T:Engine.Logging.ILog"/>
            </summary>
        </member>
        <member name="F:Engine.Logging.Log.Filename">
            <summary>
              The file to log to.
            </summary>
        </member>
        <member name="M:Engine.Logging.Log.#ctor(System.String,Engine.Logging.Frequency)">
            <summary>
              Create a log file at the given location,
              with a given expected frequency of logging
            </summary>
            <param name="filename"> </param>
            <param name="frequency"> </param>
        </member>
        <member name="M:Engine.Logging.Log.Error(System.String)">
            <summary>
              See <see cref="M:Engine.Logging.ILog.Error(System.String)"/>
            </summary>
            <param name="msg"> </param>
        </member>
        <member name="M:Engine.Logging.Log.Warn(System.String)">
            <summary>
              See <see cref="M:Engine.Logging.ILog.Warn(System.String)"/>
            </summary>
            <param name="msg"> </param>
        </member>
        <member name="M:Engine.Logging.Log.Info(System.String)">
            <summary>
              See <see cref="M:Engine.Logging.ILog.Info(System.String)"/>
            </summary>
            <param name="msg"> </param>
        </member>
        <member name="M:Engine.Logging.Log.Debug(System.String)">
            <summary>
              See <see cref="M:Engine.Logging.ILog.Debug(System.String)"/>
            </summary>
            <param name="msg"> </param>
        </member>
        <member name="M:Engine.Logging.Log.Flush">
            <summary>
              Write any pending messages to disk
            </summary>
        </member>
        <member name="T:Engine.Logging.LogLine">
            <summary>
              Used for injecting text into another log message
            </summary>
        </member>
        <member name="M:Engine.Logging.LogLine.Error(System.String)">
            <summary>
              Log an error message
            </summary>
            <param name="msg"> </param>
        </member>
        <member name="M:Engine.Logging.LogLine.Warn(System.String)">
            <summary>
              Log a warning message
            </summary>
            <param name="msg"> </param>
        </member>
        <member name="M:Engine.Logging.LogLine.Info(System.String)">
            <summary>
              Log an info message
            </summary>
            <param name="msg"> </param>
        </member>
        <member name="M:Engine.Logging.LogLine.Debug(System.String)">
            <summary>
              Log a debug message
            </summary>
            <param name="msg"> </param>
        </member>
        <member name="M:Engine.Logging.LogLine.InjectMsg(System.Action{System.String},System.String)">
            <summary>
              Called by Error/Warn/Info/Debug, used for injecting into the message
            </summary>
            <param name="func"> </param>
            <param name="msg"> </param>
        </member>
        <member name="T:Engine.Utility.InvokeExtensions">
            <summary>
            Extensions related to Invocation
            </summary>
        </member>
        <member name="M:Engine.Utility.InvokeExtensions.InvokeEx``1(``0,System.Action{``0})">
            <summary>
            If performing the action would require a synchronized invoke,
            does that for you.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="T:Engine.Input.MouseButton">
            <summary>
            Used to specify the left or right mouse button
            </summary>
        </member>
        <member name="F:Engine.Input.MouseButton.None">
            <summary>
            No mouse button
            </summary>
        </member>
        <member name="F:Engine.Input.MouseButton.Left">
            <summary>
            Left mouse button
            </summary>
        </member>
        <member name="F:Engine.Input.MouseButton.Right">
            <summary>
            Right mouse button
            </summary>
        </member>
        <member name="F:Engine.Input.MouseButton.Middle">
            <summary>
            Middle click (not scroll up/down)
            </summary>
        </member>
        <member name="T:Engine.Input.Trigger">
            <summary>
            Used to specify the left or right trigger
            </summary>
        </member>
        <member name="F:Engine.Input.Trigger.None">
            <summary>
            No trigger
            </summary>
        </member>
        <member name="F:Engine.Input.Trigger.Left">
            <summary>
            Left trigger (as viewed from top)
            </summary>
        </member>
        <member name="F:Engine.Input.Trigger.Right">
            <summary>
            Right trigger (as viewed from top)
            </summary>
        </member>
        <member name="T:Engine.Input.Thumbstick">
            <summary>
            Used to specify the left or right thumbstick
            </summary>
        </member>
        <member name="F:Engine.Input.Thumbstick.None">
            <summary>
            No thumbstick
            </summary>
        </member>
        <member name="F:Engine.Input.Thumbstick.Left">
            <summary>
            Left thumbstick (as viewed from top)
            </summary>
        </member>
        <member name="F:Engine.Input.Thumbstick.Right">
            <summary>
            Right thumbstick (as viewed from top)
            </summary>
        </member>
        <member name="T:Engine.Input.ThumbstickDirection">
            <summary>
            Used to specify the direction of a thumbstick "press" (=1)
            </summary>
        </member>
        <member name="F:Engine.Input.ThumbstickDirection.None">
            <summary>
            No direction
            </summary>
        </member>
        <member name="F:Engine.Input.ThumbstickDirection.Up">
            <summary>
            Controller up
            </summary>
        </member>
        <member name="F:Engine.Input.ThumbstickDirection.Down">
            <summary>
            Controller down
            </summary>
        </member>
        <member name="F:Engine.Input.ThumbstickDirection.Left">
            <summary>
            Controller left
            </summary>
        </member>
        <member name="F:Engine.Input.ThumbstickDirection.Right">
            <summary>
            Controller right
            </summary>
        </member>
        <member name="T:Engine.Input.FrameState">
            <summary>
            Which frame (previous or current) you are querying.
            Used when asking about a key's state
            </summary>
        </member>
        <member name="F:Engine.Input.FrameState.Previous">
            <summary>
            The frame which occured before whatever is considered the "current"
            </summary>
        </member>
        <member name="F:Engine.Input.FrameState.Current">
            <summary>
            The frame that logic is being run in right now (or graphics are being rendered in, depending on context)
            </summary>
        </member>
        <member name="T:Engine.Input.ModifierCheckType">
            <summary>
            How a manager interpolates binding checks (if at all)
            </summary>
        </member>
        <member name="F:Engine.Input.ModifierCheckType.Strict">
            <summary>
            The exact modifiers specified by the binding must be active.  No other modifiers may be active.
            </summary>
        </member>
        <member name="F:Engine.Input.ModifierCheckType.Smart">
            <summary>
            Binding A with modifiers x, y will be counted active (even if modifier z is active) so long as there is no other binding B with modifiers x, y, and z.
            </summary>
            <example>
            Jump is bound to space bar.  Fireball is 1, Fire nova is Shift + 1.
            In strict mode, Shift + Space would not jump because there are active modifiers not in the jump binidng (space w/o mods)
            In smart mode, there are no bindings with Shift + Space, so it falls back to the base binding, Jump.
            </example>
        </member>
    </members>
</doc>

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;

namespace Engine.DataStructures
{
    /// <summary>
    ///   Uses TryGetValue for index-notation lookup
    /// </summary>
    /// <typeparam name="TKey"> </typeparam>
    /// <typeparam name="TValue"> </typeparam>
    public class DefaultDict<TKey, TValue> : ConcurrentDictionary<TKey, TValue>
    {
        private readonly Func<TValue> _defaultValueFunc;

        /// <summary>
        ///   Construct a DefaultDict whose fallback value is the public parameterless constructor of TValue
        /// </summary>
        public DefaultDict()
        {
        }

        /// <summary>
        ///   Construct a DefaultDict whose fallback value is generated by the given function
        /// </summary>
        public DefaultDict(Func<TValue> defaultValueFunc = null)
        {
            _defaultValueFunc = defaultValueFunc;
        }

        /// <summary>
        ///   Construct a DefaultDict from another IDict, with a fallback value function that is the
        ///   public parameterless constructor of TVale
        /// </summary>
        public DefaultDict(IEnumerable<KeyValuePair<TKey, TValue>> other)
            : base(other)
        {
            _defaultValueFunc = null;
        }

        /// <summary>
        ///   Copy Constructor - copies the other DefaultDict's defaultValueFunc
        /// </summary>
        /// <param name="other"> </param>
        public DefaultDict(DefaultDict<TKey, TValue> other)
            : base(other)
        {
            _defaultValueFunc = other._defaultValueFunc;
        }

        /// <summary>
        ///   Gets or sets the value associated with the specified key.
        /// </summary>
        /// <param name="key"> The key of the value to get or set. </param>
        /// <returns> </returns>
        public new TValue this[TKey key]
        {
            get
            {
                TValue value;
                var found = base.TryGetValue(key, out value);
                if (!found)
                {
                    value = _defaultValueFunc == null ? default(TValue) : _defaultValueFunc();
                    base[key] = value;
                }
                return value;
            }
            set { base[key] = value; }
        }
    }

    /// <summary>
    ///   Uses TryGetValue for index-notation lookup
    /// </summary>
    /// <typeparam name="TKey"> </typeparam>
    /// <typeparam name="TValue"> </typeparam>
    public class DefaultObjDict<TKey, TValue> : ConcurrentDictionary<TKey, TValue> where TValue : new()
    {
        private readonly Func<TValue> _defaultValueFunc;

        /// <summary>
        ///   Construct a DefaultDict whose fallback value is the public parameterless constructor of TValue
        /// </summary>
        public DefaultObjDict()
        {
        }

        /// <summary>
        ///   Construct a DefaultDict whose fallback value is generated by the given function
        /// </summary>
        public DefaultObjDict(Func<TValue> defaultValueFunc = null)
        {
            _defaultValueFunc = defaultValueFunc;
        }

        /// <summary>
        ///   Construct a DefaultDict from another IDict, with a fallback value function that is the
        ///   public parameterless constructor of TVale
        /// </summary>
        public DefaultObjDict(IEnumerable<KeyValuePair<TKey, TValue>> other)
            : base(other)
        {
            _defaultValueFunc = null;
        }

        /// <summary>
        ///   Copy Constructor - copies the other DefaultDict's defaultValueFunc
        /// </summary>
        /// <param name="other"> </param>
        public DefaultObjDict(DefaultObjDict<TKey, TValue> other)
            : base(other)
        {
            _defaultValueFunc = other._defaultValueFunc;
        }

        /// <summary>
        ///   Gets or sets the value associated with the specified key.
        /// </summary>
        /// <param name="key"> The key of the value to get or set. </param>
        /// <returns> </returns>
        public new TValue this[TKey key]
        {
            get
            {
                TValue value;
                var found = base.TryGetValue(key, out value);
                if (!found)
                {
                    value = _defaultValueFunc == null ? new TValue() : _defaultValueFunc();
                    base[key] = value;
                }
                return value;
            }
            set { base[key] = value; }
        }
    }
}